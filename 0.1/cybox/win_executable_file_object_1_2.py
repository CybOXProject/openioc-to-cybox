#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Mon Apr 09 15:18:12 2012 by generateDS.py version 2.7b.
#

import sys
import getopt
import re as re_
import win_file_object_1_2 as win_file_object
import common_types_1_0 as common

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class WindowsExecutableFileObjectType(win_file_object.WindowsFileObjectType):
    """The WindowsExecutableFileObjectType type is intended to characterize
    Windows PE (Portable Executable) files."""
    subclass = None
    superclass = win_file_object.WindowsFileObjectType
    def __init__(self, is_packed=None, File_Name=None, File_Path=None, Device_Path=None, Full_Path=None, File_Extension=None, Size_In_Bytes=None, Hashes=None, Digital_Signatures=None, Modified_Time=None, Accessed_Time=None, Created_Time=None, File_Attributes_List=None, Permissions=None, User_Owner=None, Packer_List=None, Peak_Entropy=None, Sym_Links=None, Extracted_Features=None, Byte_Runs=None, Filename_Accessed_Time=None, Filename_Created_Time=None, Filename_Modified_Time=None, Drive=None, Security_ID=None, Security_Type=None, Stream_List=None, Peak_Code_Entropy=None, PE_Attributes=None):
        super(WindowsExecutableFileObjectType, self).__init__(is_packed, File_Name, File_Path, Device_Path, Full_Path, File_Extension, Size_In_Bytes, Hashes, Digital_Signatures, Modified_Time, Accessed_Time, Created_Time, File_Attributes_List, Permissions, User_Owner, Packer_List, Peak_Entropy, Sym_Links, Extracted_Features, Byte_Runs, Filename_Accessed_Time, Filename_Created_Time, Filename_Modified_Time, Drive, Security_ID, Security_Type, Stream_List)
        self.Peak_Code_Entropy = Peak_Code_Entropy
        self.PE_Attributes = PE_Attributes
    def factory(*args_, **kwargs_):
        if WindowsExecutableFileObjectType.subclass:
            return WindowsExecutableFileObjectType.subclass(*args_, **kwargs_)
        else:
            return WindowsExecutableFileObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Peak_Code_Entropy(self): return self.Peak_Code_Entropy
    def set_Peak_Code_Entropy(self, Peak_Code_Entropy): self.Peak_Code_Entropy = Peak_Code_Entropy
    def get_PE_Attributes(self): return self.PE_Attributes
    def set_PE_Attributes(self, PE_Attributes): self.PE_Attributes = PE_Attributes
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='WindowsExecutableFileObjectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WindowsExecutableFileObjectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, 'WinExecutableFileObj:', name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='WindowsExecutableFileObjectType'):
        super(WindowsExecutableFileObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='WindowsExecutableFileObjectType')
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='WindowsExecutableFileObjectType', fromsubclass_=False):
        if self.Peak_Code_Entropy is not None:
            self.Peak_Code_Entropy.export(outfile, level, namespace_, name_='Peak_Code_Entropy')
        if self.PE_Attributes is not None:
            self.PE_Attributes.export(outfile, level, namespace_, name_='PE_Attributes')
        super(WindowsExecutableFileObjectType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            self.Peak_Code_Entropy is not None or
            self.PE_Attributes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WindowsExecutableFileObjectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Peak_Code_Entropy is not None:
            showIndent(outfile, level)
            outfile.write('Peak_Code_Entropy=%s,\n' % quote_python(self.Peak_Code_Entropy).encode(ExternalEncoding))
        if self.PE_Attributes is not None:
            showIndent(outfile, level)
            outfile.write('PE_Attributes=model_.PEAttributesType(\n')
            self.PE_Attributes.exportLiteral(outfile, level, name_='PE_Attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Peak_Code_Entropy':
            Peak_Code_Entropy_ = child_.text
            Peak_Code_Entropy_ = self.gds_validate_string(Peak_Code_Entropy_, node, 'Peak_Code_Entropy')
            self.Peak_Code_Entropy = Peak_Code_Entropy_
        elif nodeName_ == 'PE_Attributes':
            obj_ = PEAttributesType.factory()
            obj_.build(child_)
            self.set_PE_Attributes(obj_)
        super(WindowsExecutableFileObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class WindowsExecutableFileObjectType


class PEAttributesType(GeneratedsSuper):
    """The PEAttributesType specifies the attributes of a file in the
    Portable Executable (PE) format, such as execuatbles or
    dynamically loaded libraries."""
    subclass = None
    superclass = None
    def __init__(self, Base_Address=None, Detected_EntryPoint_Signatures=None, Digital_Signature=None, EP_Jump_Codes=None, Exports=None, Extraneous_Bytes=None, Headers=None, Imports=None, PE_Checksum=None, PE_Timestamp=None, Resources=None, Sections=None, Strings=None, Subsystem=None, Type=None):
        self.Base_Address = Base_Address
        self.Detected_EntryPoint_Signatures = Detected_EntryPoint_Signatures
        self.Digital_Signature = Digital_Signature
        self.EP_Jump_Codes = EP_Jump_Codes
        self.Exports = Exports
        self.Extraneous_Bytes = Extraneous_Bytes
        self.Headers = Headers
        self.Imports = Imports
        self.PE_Checksum = PE_Checksum
        self.PE_Timestamp = PE_Timestamp
        self.Resources = Resources
        self.Sections = Sections
        self.Strings = Strings
        self.Subsystem = Subsystem
        self.Type = Type
    def factory(*args_, **kwargs_):
        if PEAttributesType.subclass:
            return PEAttributesType.subclass(*args_, **kwargs_)
        else:
            return PEAttributesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Base_Address(self): return self.Base_Address
    def set_Base_Address(self, Base_Address): self.Base_Address = Base_Address
    def get_Detected_EntryPoint_Signatures(self): return self.Detected_EntryPoint_Signatures
    def set_Detected_EntryPoint_Signatures(self, Detected_EntryPoint_Signatures): self.Detected_EntryPoint_Signatures = Detected_EntryPoint_Signatures
    def get_Digital_Signature(self): return self.Digital_Signature
    def set_Digital_Signature(self, Digital_Signature): self.Digital_Signature = Digital_Signature
    def get_EP_Jump_Codes(self): return self.EP_Jump_Codes
    def set_EP_Jump_Codes(self, EP_Jump_Codes): self.EP_Jump_Codes = EP_Jump_Codes
    def get_Exports(self): return self.Exports
    def set_Exports(self, Exports): self.Exports = Exports
    def get_Extraneous_Bytes(self): return self.Extraneous_Bytes
    def set_Extraneous_Bytes(self, Extraneous_Bytes): self.Extraneous_Bytes = Extraneous_Bytes
    def get_Headers(self): return self.Headers
    def set_Headers(self, Headers): self.Headers = Headers
    def get_Imports(self): return self.Imports
    def set_Imports(self, Imports): self.Imports = Imports
    def get_PE_Checksum(self): return self.PE_Checksum
    def set_PE_Checksum(self, PE_Checksum): self.PE_Checksum = PE_Checksum
    def get_PE_Timestamp(self): return self.PE_Timestamp
    def set_PE_Timestamp(self, PE_Timestamp): self.PE_Timestamp = PE_Timestamp
    def get_Resources(self): return self.Resources
    def set_Resources(self, Resources): self.Resources = Resources
    def get_Sections(self): return self.Sections
    def set_Sections(self, Sections): self.Sections = Sections
    def get_Strings(self): return self.Strings
    def set_Strings(self, Strings): self.Strings = Strings
    def get_Subsystem(self): return self.Subsystem
    def set_Subsystem(self, Subsystem): self.Subsystem = Subsystem
    def validate_SubsystemType(self, value):
        # Validate type SubsystemType, a restriction on None.
        pass
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PEType(self, value):
        # Validate type PEType, a restriction on None.
        pass
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEAttributesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEAttributesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEAttributesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEAttributesType', fromsubclass_=False):
        if self.Base_Address is not None:
            self.Base_Address.export(outfile, level, namespace_, name_='Base_Address')
        if self.Detected_EntryPoint_Signatures is not None:
            self.Detected_EntryPoint_Signatures.export(outfile, level, namespace_, name_='Detected_EntryPoint_Signatures')
        if self.Digital_Signature is not None:
            self.Digital_Signature.export(outfile, level, namespace_, name_='Digital_Signature')
        if self.EP_Jump_Codes is not None:
            self.EP_Jump_Codes.export(outfile, level, namespace_, name_='EP_Jump_Codes')
        if self.Exports is not None:
            self.Exports.export(outfile, level, namespace_, name_='Exports')
        if self.Extraneous_Bytes is not None:
            self.Extraneous_Bytes.export(outfile, level, namespace_, name_='Extraneous_Bytes')
        if self.Headers is not None:
            self.Headers.export(outfile, level, namespace_, name_='Headers')
        if self.Imports is not None:
            self.Imports.export(outfile, level, namespace_, name_='Imports')
        if self.PE_Checksum is not None:
            self.PE_Checksum.export(outfile, level, namespace_, name_='PE_Checksum')
        if self.PE_Timestamp is not None:
            self.PE_Timestamp.export(outfile, level, namespace_, name_='PE_Timestamp')
        if self.Resources is not None:
            self.Resources.export(outfile, level, namespace_, name_='Resources')
        if self.Sections is not None:
            self.Sections.export(outfile, level, namespace_, name_='Sections')
        if self.Strings is not None:
            self.Strings.export(outfile, level, namespace_, name_='Strings')
        if self.Subsystem is not None:
            self.Subsystem.export(outfile, level, namespace_, name_='Subsystem')
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type')
    def hasContent_(self):
        if (
            self.Base_Address is not None or
            self.Detected_EntryPoint_Signatures is not None or
            self.Digital_Signature is not None or
            self.EP_Jump_Codes is not None or
            self.Exports is not None or
            self.Extraneous_Bytes is not None or
            self.Headers is not None or
            self.Imports is not None or
            self.PE_Checksum is not None or
            self.PE_Timestamp is not None or
            self.Resources is not None or
            self.Sections is not None or
            self.Strings is not None or
            self.Subsystem is not None or
            self.Type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEAttributesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Base_Address is not None:
            showIndent(outfile, level)
            outfile.write('Base_Address=%s,\n' % quote_python(self.Base_Address).encode(ExternalEncoding))
        if self.Detected_EntryPoint_Signatures is not None:
            showIndent(outfile, level)
            outfile.write('Detected_EntryPoint_Signatures=model_.EntryPointSignatureListType(\n')
            self.Detected_EntryPoint_Signatures.exportLiteral(outfile, level, name_='Detected_EntryPoint_Signatures')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Digital_Signature is not None:
            showIndent(outfile, level)
            outfile.write('Digital_Signature=%s,\n' % quote_python(self.Digital_Signature).encode(ExternalEncoding))
        if self.EP_Jump_Codes is not None:
            showIndent(outfile, level)
            outfile.write('EP_Jump_Codes=model_.EPJumpCodeType(\n')
            self.EP_Jump_Codes.exportLiteral(outfile, level, name_='EP_Jump_Codes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Exports is not None:
            showIndent(outfile, level)
            outfile.write('Exports=model_.PEExportsType(\n')
            self.Exports.exportLiteral(outfile, level, name_='Exports')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Extraneous_Bytes is not None:
            showIndent(outfile, level)
            outfile.write('Extraneous_Bytes=%s,\n' % quote_python(self.Extraneous_Bytes).encode(ExternalEncoding))
        if self.Headers is not None:
            showIndent(outfile, level)
            outfile.write('Headers=model_.PEHeadersType(\n')
            self.Headers.exportLiteral(outfile, level, name_='Headers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Imports is not None:
            showIndent(outfile, level)
            outfile.write('Imports=model_.PEImportListType(\n')
            self.Imports.exportLiteral(outfile, level, name_='Imports')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PE_Checksum is not None:
            showIndent(outfile, level)
            outfile.write('PE_Checksum=model_.PEChecksumType(\n')
            self.PE_Checksum.exportLiteral(outfile, level, name_='PE_Checksum')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PE_Timestamp is not None:
            showIndent(outfile, level)
            outfile.write('PE_Timestamp=%s,\n' % quote_python(self.PE_Timestamp).encode(ExternalEncoding))
        if self.Resources is not None:
            showIndent(outfile, level)
            outfile.write('Resources=model_.PEResourceListType(\n')
            self.Resources.exportLiteral(outfile, level, name_='Resources')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Sections is not None:
            showIndent(outfile, level)
            outfile.write('Sections=model_.PESectionListType(\n')
            self.Sections.exportLiteral(outfile, level, name_='Sections')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Strings is not None:
            showIndent(outfile, level)
            outfile.write('Strings=model_.StringListType(\n')
            self.Strings.exportLiteral(outfile, level, name_='Strings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Subsystem is not None:
            showIndent(outfile, level)
            outfile.write('Subsystem=model_.SubsystemType(\n')
            self.Subsystem.exportLiteral(outfile, level, name_='Subsystem')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=model_.PEType(\n')
            self.Type.exportLiteral(outfile, level, name_='Type')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Base_Address':
            Base_Address_ = common.HexBinaryObjectAttributeType.factoy()
            Base_Address_.build(child_)
            self.set_Base_Address(Base_Address_)
        elif nodeName_ == 'Detected_EntryPoint_Signatures':
            obj_ = EntryPointSignatureListType.factory()
            obj_.build(child_)
            self.set_Detected_EntryPoint_Signatures(obj_)
        elif nodeName_ == 'Digital_Signature':
            Digital_Signature_ = common.DigitalSignatureInfoType.factory()
            Digital_Signature_.build(child_)
            self.set_Digital_Signature(Digital_Signature_)
        elif nodeName_ == 'EP_Jump_Codes':
            obj_ = EPJumpCodeType.factory()
            obj_.build(child_)
            self.set_EP_Jump_Codes(obj_)
        elif nodeName_ == 'Exports':
            obj_ = PEExportsType.factory()
            obj_.build(child_)
            self.set_Exports(obj_)
        elif nodeName_ == 'Extraneous_Bytes':
            Extraneous_Bytes_ = common.IntegerObjectAttributeType.factory()
            Extraneous_Bytes_.build(child_)
            self.set_Extraneous_Bytes(Extraneous_Bytes_)
        elif nodeName_ == 'Headers':
            obj_ = PEHeadersType.factory()
            obj_.build(child_)
            self.set_Headers(obj_)
        elif nodeName_ == 'Imports':
            obj_ = PEImportListType.factory()
            obj_.build(child_)
            self.set_Imports(obj_)
        elif nodeName_ == 'PE_Checksum':
            obj_ = PEChecksumType.factory()
            obj_.build(child_)
            self.set_PE_Checksum(obj_)
        elif nodeName_ == 'PE_Timestamp':
            PE_Timestamp_ = common.DateTimeObjectAttributeType().factory()
            PE_Timestamp_.build(child_)
            self.set_PE_Timestamp(PE_Timestamp_)
        elif nodeName_ == 'Resources':
            obj_ = PEResourceListType.factory()
            obj_.build(child_)
            self.set_Resources(obj_)
        elif nodeName_ == 'Sections':
            obj_ = PESectionListType.factory()
            obj_.build(child_)
            self.set_Sections(obj_)
        elif nodeName_ == 'Strings':
            obj_ = StringListType.factory()
            obj_.build(child_)
            self.set_Strings(obj_)
        elif nodeName_ == 'Subsystem':
            obj_ = common.StringObjectAttributeType.factory()
            obj_.build(child_)
            self.set_Subsystem(obj_)
            self.validate_SubsystemType(self.Subsystem)    # validate type SubsystemType
        elif nodeName_ == 'Type':
            obj_ = common.StringObjectAttributeType.factory()
            obj_.build(child_)
            self.set_Type(obj_)
            self.validate_PEType(self.Type)    # validate type PEType
# end class PEAttributesType


class PEChecksumType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PE_Computed_API=None, PE_File_API=None, PE_File_Raw=None):
        self.PE_Computed_API = PE_Computed_API
        self.PE_File_API = PE_File_API
        self.PE_File_Raw = PE_File_Raw
    def factory(*args_, **kwargs_):
        if PEChecksumType.subclass:
            return PEChecksumType.subclass(*args_, **kwargs_)
        else:
            return PEChecksumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PE_Computed_API(self): return self.PE_Computed_API
    def set_PE_Computed_API(self, PE_Computed_API): self.PE_Computed_API = PE_Computed_API
    def get_PE_File_API(self): return self.PE_File_API
    def set_PE_File_API(self, PE_File_API): self.PE_File_API = PE_File_API
    def get_PE_File_Raw(self): return self.PE_File_Raw
    def set_PE_File_Raw(self, PE_File_Raw): self.PE_File_Raw = PE_File_Raw
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEChecksumType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEChecksumType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEChecksumType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEChecksumType', fromsubclass_=False):
        if self.PE_Computed_API is not None:
            self.PE_Computed_API.export(outfile, level, namespace_, name_='PE_Computed_API')
        if self.PE_File_API is not None:
            self.PE_File_API.export(outfile, level, namespace_, name_='PE_File_API')
        if self.PE_File_Raw is not None:
            self.PE_File_Raw.export(outfile, level, namespace_, name_='PE_File_Raw')
    def hasContent_(self):
        if (
            self.PE_Computed_API is not None or
            self.PE_File_API is not None or
            self.PE_File_Raw is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEChecksumType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PE_Computed_API is not None:
            showIndent(outfile, level)
            outfile.write('PE_Computed_API=%s,\n' % quote_python(self.PE_Computed_API).encode(ExternalEncoding))
        if self.PE_File_API is not None:
            showIndent(outfile, level)
            outfile.write('PE_File_API=%s,\n' % quote_python(self.PE_File_API).encode(ExternalEncoding))
        if self.PE_File_Raw is not None:
            showIndent(outfile, level)
            outfile.write('PE_File_Raw=%s,\n' % quote_python(self.PE_File_Raw).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PE_Computed_API':
            PE_Computed_API_ = child_.text
            PE_Computed_API_ = self.gds_validate_string(PE_Computed_API_, node, 'PE_Computed_API')
            self.PE_Computed_API = PE_Computed_API_
        elif nodeName_ == 'PE_File_API':
            PE_File_API_ = child_.text
            PE_File_API_ = self.gds_validate_string(PE_File_API_, node, 'PE_File_API')
            self.PE_File_API = PE_File_API_
        elif nodeName_ == 'PE_File_Raw':
            PE_File_Raw_ = child_.text
            PE_File_Raw_ = self.gds_validate_string(PE_File_Raw_, node, 'PE_File_Raw')
            self.PE_File_Raw = PE_File_Raw_
# end class PEChecksumType


class PEExportsType(GeneratedsSuper):
    """PEExportsType specifies the PE File exports data section. The
    exports data section contains information about symbols exported
    by the PE File (a DLL) which can be dynamically loaded by other
    executables. This type abstracts, and its components, abstract
    the Windows structures."""
    subclass = None
    superclass = None
    def __init__(self, Exported_Functions=None, Exports_Time_Stamp=None, Number_Of_Addresses=None, Number_Of_Names=None):
        self.Exported_Functions = Exported_Functions
        self.Exports_Time_Stamp = Exports_Time_Stamp
        self.Number_Of_Addresses = Number_Of_Addresses
        self.Number_Of_Names = Number_Of_Names
    def factory(*args_, **kwargs_):
        if PEExportsType.subclass:
            return PEExportsType.subclass(*args_, **kwargs_)
        else:
            return PEExportsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Exported_Functions(self): return self.Exported_Functions
    def set_Exported_Functions(self, Exported_Functions): self.Exported_Functions = Exported_Functions
    def get_Exports_Time_Stamp(self): return self.Exports_Time_Stamp
    def set_Exports_Time_Stamp(self, Exports_Time_Stamp): self.Exports_Time_Stamp = Exports_Time_Stamp
    def get_Number_Of_Addresses(self): return self.Number_Of_Addresses
    def set_Number_Of_Addresses(self, Number_Of_Addresses): self.Number_Of_Addresses = Number_Of_Addresses
    def get_Number_Of_Names(self): return self.Number_Of_Names
    def set_Number_Of_Names(self, Number_Of_Names): self.Number_Of_Names = Number_Of_Names
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEExportsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEExportsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEExportsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEExportsType', fromsubclass_=False):
        if self.Exported_Functions is not None:
            self.Exported_Functions.export(outfile, level, namespace_, name_='Exported_Functions')
        if self.Exports_Time_Stamp is not None:
            self.Exports_Time_Stamp.export(outfile, level, namespace_, name_='Exports_Time_Stamp')
        if self.Number_Of_Addresses is not None:
            self.Number_Of_Addresses.export(outfile, level, namespace_, name_='Number_Of_Addresses')
        if self.Number_Of_Names is not None:
            self.Number_Of_Names.export(outfile, level, namespace_, name_='Number_Of_Names')
    def hasContent_(self):
        if (
            self.Exported_Functions is not None or
            self.Exports_Time_Stamp is not None or
            self.Number_Of_Addresses is not None or
            self.Number_Of_Names is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEExportsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Exported_Functions is not None:
            showIndent(outfile, level)
            outfile.write('Exported_Functions=model_.PEExportedFunctionsType(\n')
            self.Exported_Functions.exportLiteral(outfile, level, name_='Exported_Functions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Exports_Time_Stamp is not None:
            showIndent(outfile, level)
            outfile.write('Exports_Time_Stamp=%s,\n' % quote_python(self.Exports_Time_Stamp).encode(ExternalEncoding))
        if self.Number_Of_Addresses is not None:
            showIndent(outfile, level)
            outfile.write('Number_Of_Addresses=%s,\n' % quote_python(self.Number_Of_Addresses).encode(ExternalEncoding))
        if self.Number_Of_Names is not None:
            showIndent(outfile, level)
            outfile.write('Number_Of_Names=%s,\n' % quote_python(self.Number_Of_Names).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Exported_Functions':
            obj_ = PEExportedFunctionsType.factory()
            obj_.build(child_)
            self.set_Exported_Functions(obj_)
        elif nodeName_ == 'Exports_Time_Stamp':
            Exports_Time_Stamp_ = common.DateTimeObjectAttributeType.factory()
            Exports_Time_Stamp_.build(child_)
            self.set_Exports_Time_Stamp(Exports_Time_Stamp_)
        elif nodeName_ == 'Number_Of_Addresses':
            Number_Of_Addresses_ = child_.text
            Number_Of_Addresses_ = self.gds_validate_string(Number_Of_Addresses_, node, 'Number_Of_Addresses')
            self.Number_Of_Addresses = Number_Of_Addresses_
        elif nodeName_ == 'Number_Of_Names':
            Number_Of_Names_ = common.LongObjectAttributeType.factory()
            Number_Of_Names_.build(child_)
            self.set_Number_Of_Names(Number_Of_Names_)
# end class PEExportsType


class PEExportedFunctionsType(GeneratedsSuper):
    """PEExportedFunctionsType specifies a list of PE exported functions"""
    subclass = None
    superclass = None
    def __init__(self, Exported_Function=None):
        if Exported_Function is None:
            self.Exported_Function = []
        else:
            self.Exported_Function = Exported_Function
    def factory(*args_, **kwargs_):
        if PEExportedFunctionsType.subclass:
            return PEExportedFunctionsType.subclass(*args_, **kwargs_)
        else:
            return PEExportedFunctionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Exported_Function(self): return self.Exported_Function
    def set_Exported_Function(self, Exported_Function): self.Exported_Function = Exported_Function
    def add_Exported_Function(self, value): self.Exported_Function.append(value)
    def insert_Exported_Function(self, index, value): self.Exported_Function[index] = value
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEExportedFunctionsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEExportedFunctionsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEExportedFunctionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEExportedFunctionsType', fromsubclass_=False):
        for Exported_Function_ in self.Exported_Function:
            Exported_Function_.export(outfile, level, namespace_, name_='Exported_Function')
    def hasContent_(self):
        if (
            self.Exported_Function
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEExportedFunctionsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Exported_Function=[\n')
        level += 1
        for Exported_Function_ in self.Exported_Function:
            showIndent(outfile, level)
            outfile.write('model_.PEExportedFunctionType(\n')
            Exported_Function_.exportLiteral(outfile, level, name_='PEExportedFunctionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Exported_Function':
            obj_ = PEExportedFunctionType.factory()
            obj_.build(child_)
            self.Exported_Function.append(obj_)
# end class PEExportedFunctionsType


class StringListType(GeneratedsSuper):
    """StringListType specifies a list of strings contained in the PE File."""
    subclass = None
    superclass = None
    def __init__(self, String=None):
        if String is None:
            self.String = []
        else:
            self.String = String
    def factory(*args_, **kwargs_):
        if StringListType.subclass:
            return StringListType.subclass(*args_, **kwargs_)
        else:
            return StringListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_String(self): return self.String
    def set_String(self, String): self.String = String
    def add_String(self, value): self.String.append(value)
    def insert_String(self, index, value): self.String[index] = value
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='StringListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='StringListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='StringListType', fromsubclass_=False):
        for String_ in self.String:
            String_.export(outfile, level, namespace_, name_='String')
    def hasContent_(self):
        if (
            self.String
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StringListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('String=[\n')
        level += 1
        for String_ in self.String:
            showIndent(outfile, level)
            outfile.write('model_.PEStringType(\n')
            String_.exportLiteral(outfile, level, name_='PEStringType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'String':
            obj_ = PEStringType.factory()
            obj_.build(child_)
            self.String.append(obj_)
# end class StringListType


class EPJumpCodeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Depth=None, Opcodes=None):
        self.Depth = Depth
        self.Opcodes = Opcodes
    def factory(*args_, **kwargs_):
        if EPJumpCodeType.subclass:
            return EPJumpCodeType.subclass(*args_, **kwargs_)
        else:
            return EPJumpCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Depth(self): return self.Depth
    def set_Depth(self, Depth): self.Depth = Depth
    def get_Opcodes(self): return self.Opcodes
    def set_Opcodes(self, Opcodes): self.Opcodes = Opcodes
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='EPJumpCodeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EPJumpCodeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='EPJumpCodeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='EPJumpCodeType', fromsubclass_=False):
        if self.Depth is not None:
            self.Depth.export(outfile, level, namespace_, name_='Depth')
        if self.Opcodes is not None:
            self.Opcodes.export(outfile, level, namespace_, name_='Opcodes')
    def hasContent_(self):
        if (
            self.Depth is not None or
            self.Opcodes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EPJumpCodeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Depth is not None:
            showIndent(outfile, level)
            outfile.write('Depth=%s,\n' % quote_python(self.Depth).encode(ExternalEncoding))
        if self.Opcodes is not None:
            showIndent(outfile, level)
            outfile.write('Opcodes=%s,\n' % quote_python(self.Opcodes).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Depth':
            Depth_ = child_.text
            Depth_ = self.gds_validate_string(Depth_, node, 'Depth')
            self.Depth = Depth_
        elif nodeName_ == 'Opcodes':
            Opcodes_ = child_.text
            Opcodes_ = self.gds_validate_string(Opcodes_, node, 'Opcodes')
            self.Opcodes = Opcodes_
# end class EPJumpCodeType


class EntryPointSignatureType(GeneratedsSuper):
    """Specifies an entry point signature."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Type=None):
        self.Name = Name
        self.Type = Type
    def factory(*args_, **kwargs_):
        if EntryPointSignatureType.subclass:
            return EntryPointSignatureType.subclass(*args_, **kwargs_)
        else:
            return EntryPointSignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_DetectedType(self, value):
        # Validate type DetectedType, a restriction on None.
        pass
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='EntryPointSignatureType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryPointSignatureType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='EntryPointSignatureType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='EntryPointSignatureType', fromsubclass_=False):
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name')
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntryPointSignatureType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=model_.DetectedType(\n')
            self.Type.exportLiteral(outfile, level, name_='Type')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Type':
            obj_ = None
            self.set_Type(obj_)
            self.validate_DetectedType(self.Type)    # validate type DetectedType
# end class EntryPointSignatureType


class EntryPointSignatureListType(GeneratedsSuper):
    """Species a list of entry point signatures."""
    subclass = None
    superclass = None
    def __init__(self, Entry_Point_Signature=None):
        if Entry_Point_Signature is None:
            self.Entry_Point_Signature = []
        else:
            self.Entry_Point_Signature = Entry_Point_Signature
    def factory(*args_, **kwargs_):
        if EntryPointSignatureListType.subclass:
            return EntryPointSignatureListType.subclass(*args_, **kwargs_)
        else:
            return EntryPointSignatureListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Entry_Point_Signature(self): return self.Entry_Point_Signature
    def set_Entry_Point_Signature(self, Entry_Point_Signature): self.Entry_Point_Signature = Entry_Point_Signature
    def add_Entry_Point_Signature(self, value): self.Entry_Point_Signature.append(value)
    def insert_Entry_Point_Signature(self, index, value): self.Entry_Point_Signature[index] = value
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='EntryPointSignatureListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryPointSignatureListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='EntryPointSignatureListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='EntryPointSignatureListType', fromsubclass_=False):
        for Entry_Point_Signature_ in self.Entry_Point_Signature:
            Entry_Point_Signature_.export(outfile, level, namespace_, name_='Entry_Point_Signature')
    def hasContent_(self):
        if (
            self.Entry_Point_Signature
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntryPointSignatureListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Entry_Point_Signature=[\n')
        level += 1
        for Entry_Point_Signature_ in self.Entry_Point_Signature:
            showIndent(outfile, level)
            outfile.write('model_.EntryPointSignatureType(\n')
            Entry_Point_Signature_.exportLiteral(outfile, level, name_='EntryPointSignatureType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Entry_Point_Signature':
            obj_ = EntryPointSignatureType.factory()
            obj_.build(child_)
            self.Entry_Point_Signature.append(obj_)
# end class EntryPointSignatureListType


class PESectionListType(GeneratedsSuper):
    """Specifies a list of sections that appear in the PE file."""
    subclass = None
    superclass = None
    def __init__(self, Section=None):
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
    def factory(*args_, **kwargs_):
        if PESectionListType.subclass:
            return PESectionListType.subclass(*args_, **kwargs_)
        else:
            return PESectionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section(self, index, value): self.Section[index] = value
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PESectionListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PESectionListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PESectionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PESectionListType', fromsubclass_=False):
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_, name_='Section')
    def hasContent_(self):
        if (
            self.Section
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PESectionListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.PESectionType(\n')
            Section_.exportLiteral(outfile, level, name_='PESectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Section':
            obj_ = PESectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
# end class PESectionListType


class FloatListType(GeneratedsSuper):
    """Specifies a list of floating point numbers."""
    subclass = None
    superclass = None
    def __init__(self, Float=None):
        if Float is None:
            self.Float = []
        else:
            self.Float = Float
    def factory(*args_, **kwargs_):
        if FloatListType.subclass:
            return FloatListType.subclass(*args_, **kwargs_)
        else:
            return FloatListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Float(self): return self.Float
    def set_Float(self, Float): self.Float = Float
    def add_Float(self, value): self.Float.append(value)
    def insert_Float(self, index, value): self.Float[index] = value
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='FloatListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='FloatListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='FloatListType', fromsubclass_=False):
        for Float_ in self.Float:
            Float_.export(outfile, level, namespace_, name_='Float')
    def hasContent_(self):
        if (
            self.Float
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FloatListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Float=[\n')
        level += 1
        for Float_ in self.Float:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Float_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Float':
            Float_ = child_.text
            Float_ = self.gds_validate_string(Float_, node, 'Float')
            self.Float.append(Float_)
# end class FloatListType


class PEStringType(GeneratedsSuper):
    """The PEStringType type is intended as container for strings extracted
    from PE binaries."""
    subclass = None
    superclass = None
    def __init__(self, Encoding=None, Address=None, Hashes=None, Language=None, Length=None, String_Value=None, Translation=None):
        self.Encoding = Encoding
        self.Address = Address
        self.Hashes = Hashes
        self.Language = Language
        self.Length = Length
        self.String_Value = String_Value
        self.Translation = Translation
    def factory(*args_, **kwargs_):
        if PEStringType.subclass:
            return PEStringType.subclass(*args_, **kwargs_)
        else:
            return PEStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Encoding(self): return self.Encoding
    def set_Encoding(self, Encoding): self.Encoding = Encoding
    def validate_CharacterEncodingEnum(self, value):
        # Validate type CharacterEncodingEnum, a restriction on xs:string.
        pass
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Hashes(self): return self.Hashes
    def set_Hashes(self, Hashes): self.Hashes = Hashes
    def get_Language(self): return self.Language
    def set_Language(self, Language): self.Language = Language
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def get_String_Value(self): return self.String_Value
    def set_String_Value(self, String_Value): self.String_Value = String_Value
    def get_Translation(self): return self.Translation
    def set_Translation(self, Translation): self.Translation = Translation
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEStringType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEStringType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEStringType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEStringType', fromsubclass_=False):
        if self.Encoding is not None:
            self.Encoding.export(outfile, level, namespace_, name_='Encoding')
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address')
        if self.Hashes is not None:
            self.Hashes.export(outfile, level, namespace_, name_='Hashes')
        if self.Language is not None:
            self.Language.export(outfile, level, namespace_, name_='Language')
        if self.Length is not None:
            self.Length.export(outfile, level, namespace_, name_='Length')
        if self.String_Value is not None:
            self.String_Value.export(outfile, level, namespace_, name_='String_Value')
        if self.Translation is not None:
            self.Translation.export(outfile, level, namespace_, name_='Translation')
    def hasContent_(self):
        if (
            self.Encoding is not None or
            self.Address is not None or
            self.Hashes is not None or
            self.Language is not None or
            self.Length is not None or
            self.String_Value is not None or
            self.Translation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEStringType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Encoding is not None:
            showIndent(outfile, level)
            outfile.write('Encoding=%s,\n' % quote_python(self.Encoding).encode(ExternalEncoding))
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('Address=%s,\n' % quote_python(self.Address).encode(ExternalEncoding))
        if self.Hashes is not None:
            showIndent(outfile, level)
            outfile.write('Hashes=%s,\n' % quote_python(self.Hashes).encode(ExternalEncoding))
        if self.Language is not None:
            showIndent(outfile, level)
            outfile.write('Language=%s,\n' % quote_python(self.Language).encode(ExternalEncoding))
        if self.Length is not None:
            showIndent(outfile, level)
            outfile.write('Length=%s,\n' % quote_python(self.Length).encode(ExternalEncoding))
        if self.String_Value is not None:
            showIndent(outfile, level)
            outfile.write('String_Value=%s,\n' % quote_python(self.String_Value).encode(ExternalEncoding))
        if self.Translation is not None:
            showIndent(outfile, level)
            outfile.write('Translation=%s,\n' % quote_python(self.Translation).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Encoding':
            Encoding_ = child_.text
            Encoding_ = self.gds_validate_string(Encoding_, node, 'Encoding')
            self.Encoding = Encoding_
            self.validate_CharacterEncodingEnum(self.Encoding)    # validate type CharacterEncodingEnum
        elif nodeName_ == 'Address':
            Address_ = child_.text
            Address_ = self.gds_validate_string(Address_, node, 'Address')
            self.Address = Address_
        elif nodeName_ == 'Hashes':
            Hashes_ = child_.text
            Hashes_ = self.gds_validate_string(Hashes_, node, 'Hashes')
            self.Hashes = Hashes_
        elif nodeName_ == 'Language':
            Language_ = child_.text
            Language_ = self.gds_validate_string(Language_, node, 'Language')
            self.Language = Language_
        elif nodeName_ == 'Length':
            Length_ = child_.text
            Length_ = self.gds_validate_string(Length_, node, 'Length')
            self.Length = Length_
        elif nodeName_ == 'String_Value':
            String_Value_ = child_.text
            String_Value_ = self.gds_validate_string(String_Value_, node, 'String_Value')
            self.String_Value = String_Value_
        elif nodeName_ == 'Translation':
            Translation_ = child_.text
            Translation_ = self.gds_validate_string(Translation_, node, 'Translation')
            self.Translation = Translation_
# end class PEStringType


class PEImportType(GeneratedsSuper):
    """The PEImportType type is intended as container for the attributes
    relevant to PE binary imports.The delay_load attribute is a
    boolean value that is intended to describe whether a PE binary
    import is delay-load or not.The initially_visible attribute
    refers to whether the import is initially visible, with regards
    to being initially visible or hidden in relation to PE binary
    packing. A packed binary will typically have few initially
    visible imports, and thus it is necessary to make the
    distinction between those that are visible initially or only
    after the binary is unpacked."""
    subclass = None
    superclass = None
    def __init__(self, initially_visible=None, delay_load=None, File_Name=None, Imported_Functions=None, Virtual_Address=None):
        self.initially_visible = _cast(bool, initially_visible)
        self.delay_load = _cast(bool, delay_load)
        self.File_Name = File_Name
        self.Imported_Functions = Imported_Functions
        self.Virtual_Address = Virtual_Address
    def factory(*args_, **kwargs_):
        if PEImportType.subclass:
            return PEImportType.subclass(*args_, **kwargs_)
        else:
            return PEImportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_File_Name(self): return self.File_Name
    def set_File_Name(self, File_Name): self.File_Name = File_Name
    def get_Imported_Functions(self): return self.Imported_Functions
    def set_Imported_Functions(self, Imported_Functions): self.Imported_Functions = Imported_Functions
    def get_Virtual_Address(self): return self.Virtual_Address
    def set_Virtual_Address(self, Virtual_Address): self.Virtual_Address = Virtual_Address
    def get_initially_visible(self): return self.initially_visible
    def set_initially_visible(self, initially_visible): self.initially_visible = initially_visible
    def get_delay_load(self): return self.delay_load
    def set_delay_load(self, delay_load): self.delay_load = delay_load
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEImportType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEImportType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEImportType'):
        if self.initially_visible is not None and 'initially_visible' not in already_processed:
            already_processed.append('initially_visible')
            outfile.write(' initially_visible="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.initially_visible)), input_name='initially_visible'))
        if self.delay_load is not None and 'delay_load' not in already_processed:
            already_processed.append('delay_load')
            outfile.write(' delay_load="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.delay_load)), input_name='delay_load'))
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEImportType', fromsubclass_=False):
        if self.File_Name is not None:
            self.File_Name.export(outfile, level, namespace_, name_='File_Name')
        if self.Imported_Functions is not None:
            self.Imported_Functions.export(outfile, level, namespace_, name_='Imported_Functions')
        if self.Virtual_Address is not None:
            self.Virtual_Address.export(outfile, level, namespace_, name_='Virtual_Address')
    def hasContent_(self):
        if (
            self.File_Name is not None or
            self.Imported_Functions is not None or
            self.Virtual_Address is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEImportType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.initially_visible is not None and 'initially_visible' not in already_processed:
            already_processed.append('initially_visible')
            showIndent(outfile, level)
            outfile.write('initially_visible = %s,\n' % (self.initially_visible,))
        if self.delay_load is not None and 'delay_load' not in already_processed:
            already_processed.append('delay_load')
            showIndent(outfile, level)
            outfile.write('delay_load = %s,\n' % (self.delay_load,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.File_Name is not None:
            showIndent(outfile, level)
            outfile.write('File_Name=%s,\n' % quote_python(self.File_Name).encode(ExternalEncoding))
        if self.Imported_Functions is not None:
            showIndent(outfile, level)
            outfile.write('Imported_Functions=model_.PEImportedFunctionsType(\n')
            self.Imported_Functions.exportLiteral(outfile, level, name_='Imported_Functions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Virtual_Address is not None:
            showIndent(outfile, level)
            outfile.write('Virtual_Address=%s,\n' % quote_python(self.Virtual_Address).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initially_visible', node)
        if value is not None and 'initially_visible' not in already_processed:
            already_processed.append('initially_visible')
            if value in ('true', '1'):
                self.initially_visible = True
            elif value in ('false', '0'):
                self.initially_visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('delay_load', node)
        if value is not None and 'delay_load' not in already_processed:
            already_processed.append('delay_load')
            if value in ('true', '1'):
                self.delay_load = True
            elif value in ('false', '0'):
                self.delay_load = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'File_Name':
            File_Name_ = child_.text
            File_Name_ = self.gds_validate_string(File_Name_, node, 'File_Name')
            self.File_Name = File_Name_
        elif nodeName_ == 'Imported_Functions':
            obj_ = PEImportedFunctionsType.factory()
            obj_.build(child_)
            self.set_Imported_Functions(obj_)
        elif nodeName_ == 'Virtual_Address':
            Virtual_Address_ = child_.text
            Virtual_Address_ = self.gds_validate_string(Virtual_Address_, node, 'Virtual_Address')
            self.Virtual_Address = Virtual_Address_
# end class PEImportType


class PEImportedFunctionsType(GeneratedsSuper):
    """A list of PE imported functions"""
    subclass = None
    superclass = None
    def __init__(self, Imported_Function=None):
        if Imported_Function is None:
            self.Imported_Function = []
        else:
            self.Imported_Function = Imported_Function
    def factory(*args_, **kwargs_):
        if PEImportedFunctionsType.subclass:
            return PEImportedFunctionsType.subclass(*args_, **kwargs_)
        else:
            return PEImportedFunctionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Imported_Function(self): return self.Imported_Function
    def set_Imported_Function(self, Imported_Function): self.Imported_Function = Imported_Function
    def add_Imported_Function(self, value): self.Imported_Function.append(value)
    def insert_Imported_Function(self, index, value): self.Imported_Function[index] = value
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEImportedFunctionsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEImportedFunctionsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEImportedFunctionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEImportedFunctionsType', fromsubclass_=False):
        for Imported_Function_ in self.Imported_Function:
            Imported_Function_.export(outfile, level, namespace_, name_='Imported_Function')
    def hasContent_(self):
        if (
            self.Imported_Function
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEImportedFunctionsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Imported_Function=[\n')
        level += 1
        for Imported_Function_ in self.Imported_Function:
            showIndent(outfile, level)
            outfile.write('model_.PEImportedFunctionType(\n')
            Imported_Function_.exportLiteral(outfile, level, name_='PEImportedFunctionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Imported_Function':
            obj_ = PEImportedFunctionType.factory()
            obj_.build(child_)
            self.Imported_Function.append(obj_)
# end class PEImportedFunctionsType


class PEResourceType(GeneratedsSuper):
    """The PEResourceType type is intended as container for the attributes
    relevant to PE binary resources."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Name=None, Hashes=None):
        self.Type = Type
        self.Name = Name
        self.Hashes = Hashes
    def factory(*args_, **kwargs_):
        if PEResourceType.subclass:
            return PEResourceType.subclass(*args_, **kwargs_)
        else:
            return PEResourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PEResourceTypeEnum(self, value):
        # Validate type PEResourceTypeEnum, a restriction on xs:string.
        pass
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Hashes(self): return self.Hashes
    def set_Hashes(self, Hashes): self.Hashes = Hashes
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEResourceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEResourceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEResourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEResourceType', fromsubclass_=False):
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type')
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name')
        if self.Hashes is not None:
            self.Hashes.export(outfile, level, namespace_, name_='Hashes')
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Name is not None or
            self.Hashes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEResourceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Hashes is not None:
            showIndent(outfile, level)
            outfile.write('Hashes=%s,\n' % quote_python(self.Hashes).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = common.StringObjectAttributeType.factory()
            Type_.build(child_)
            self.set_Type(Type_)
            self.validate_PEResourceTypeEnum(self.Type)    # validate type PEResourceTypeEnum
        elif nodeName_ == 'Name':
            Name_ = common.StringObjectAttributeType.factory()
            Name_.build(child_)
            self.Name = Name_
        elif nodeName_ == 'Hashes':
            Hashes_ = common.StringObjectAttributeType.factory()
            Hashes_.build(child_)
            self.Hashes = Hashes_
# end class PEResourceType


class PEExportedFunctionType(GeneratedsSuper):
    """PEExportType sepcifies the type describing exported functions."""
    subclass = None
    superclass = None
    def __init__(self, Function_Name=None, Entry_Point=None, Ordinal=None):
        self.Function_Name = Function_Name
        self.Entry_Point = Entry_Point
        self.Ordinal = Ordinal
    def factory(*args_, **kwargs_):
        if PEExportedFunctionType.subclass:
            return PEExportedFunctionType.subclass(*args_, **kwargs_)
        else:
            return PEExportedFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Function_Name(self): return self.Function_Name
    def set_Function_Name(self, Function_Name): self.Function_Name = Function_Name
    def get_Entry_Point(self): return self.Entry_Point
    def set_Entry_Point(self, Entry_Point): self.Entry_Point = Entry_Point
    def get_Ordinal(self): return self.Ordinal
    def set_Ordinal(self, Ordinal): self.Ordinal = Ordinal
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEExportedFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEExportedFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEExportedFunctionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEExportedFunctionType', fromsubclass_=False):
        if self.Function_Name is not None:
            self.Function_Name.export(outfile, level, namespace_, name_='Function_Name')
        if self.Entry_Point is not None:
            self.Entry_Point.export(outfile, level, namespace_, name_='Entry_Point')
        if self.Ordinal is not None:
            self.Ordinal.export(outfile, level, namespace_, name_='Ordinal')
    def hasContent_(self):
        if (
            self.Function_Name is not None or
            self.Entry_Point is not None or
            self.Ordinal is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEExportedFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Function_Name is not None:
            showIndent(outfile, level)
            outfile.write('Function_Name=%s,\n' % quote_python(self.Function_Name).encode(ExternalEncoding))
        if self.Entry_Point is not None:
            showIndent(outfile, level)
            outfile.write('Entry_Point=%s,\n' % quote_python(self.Entry_Point).encode(ExternalEncoding))
        if self.Ordinal is not None:
            showIndent(outfile, level)
            outfile.write('Ordinal=%s,\n' % quote_python(self.Ordinal).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Function_Name':
            Function_Name_ = common.StringObjectAttributeType.factory()
            Function_Name_.build(child_)
            self.set_Function_Name(Function_Name_)
        elif nodeName_ == 'Entry_Point':
            Entry_Point_ = common.StringObjectAttributeType.factory()
            Entry_Point_.build(child_)
            self.set_Entry_Point(Entry_Point_)
        elif nodeName_ == 'Ordinal':
            Ordinal_ = child_.text
            Ordinal_ = self.gds_validate_string(Ordinal_, node, 'Ordinal')
            self.Ordinal = Ordinal_
# end class PEExportedFunctionType


class PEResourceListType(GeneratedsSuper):
    """PEResourceListType specifies a list of resources found in the PE
    file."""
    subclass = None
    superclass = None
    def __init__(self, Resource=None):
        if Resource is None:
            self.Resource = []
        else:
            self.Resource = Resource
    def factory(*args_, **kwargs_):
        if PEResourceListType.subclass:
            return PEResourceListType.subclass(*args_, **kwargs_)
        else:
            return PEResourceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Resource(self): return self.Resource
    def set_Resource(self, Resource): self.Resource = Resource
    def add_Resource(self, value): self.Resource.append(value)
    def insert_Resource(self, index, value): self.Resource[index] = value
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEResourceListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEResourceListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEResourceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEResourceListType', fromsubclass_=False):
        for Resource_ in self.Resource:
            Resource_.export(outfile, level, namespace_, name_='Resource')
    def hasContent_(self):
        if (
            self.Resource
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEResourceListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Resource=[\n')
        level += 1
        for Resource_ in self.Resource:
            showIndent(outfile, level)
            outfile.write('model_.PEResourceType(\n')
            Resource_.exportLiteral(outfile, level, name_='PEResourceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Resource':
            obj_ = PEResourceType.factory()
            obj_.build(child_)
            self.Resource.append(obj_)
# end class PEResourceListType


class PEImportedFunctionType(GeneratedsSuper):
    """PEImportedFunctionType specifies the type describing imported
    functions."""
    subclass = None
    superclass = None
    def __init__(self, Function_Name=None, Hint=None, Ordinal=None, Bound=None, Virtual_Address=None):
        self.Function_Name = Function_Name
        self.Hint = Hint
        self.Ordinal = Ordinal
        self.Bound = Bound
        self.Virtual_Address = Virtual_Address
    def factory(*args_, **kwargs_):
        if PEImportedFunctionType.subclass:
            return PEImportedFunctionType.subclass(*args_, **kwargs_)
        else:
            return PEImportedFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Function_Name(self): return self.Function_Name
    def set_Function_Name(self, Function_Name): self.Function_Name = Function_Name
    def get_Hint(self): return self.Hint
    def set_Hint(self, Hint): self.Hint = Hint
    def get_Ordinal(self): return self.Ordinal
    def set_Ordinal(self, Ordinal): self.Ordinal = Ordinal
    def get_Bound(self): return self.Bound
    def set_Bound(self, Bound): self.Bound = Bound
    def get_Virtual_Address(self): return self.Virtual_Address
    def set_Virtual_Address(self, Virtual_Address): self.Virtual_Address = Virtual_Address
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEImportedFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEImportedFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEImportedFunctionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEImportedFunctionType', fromsubclass_=False):
        if self.Function_Name is not None:
            self.Function_Name.export(outfile, level, namespace_, name_='Function_Name')
        if self.Hint is not None:
            self.Hint.export(outfile, level, namespace_, name_='Hint')
        if self.Ordinal is not None:
            self.Ordinal.export(outfile, level, namespace_, name_='Ordinal')
        if self.Bound is not None:
            self.Bound.export(outfile, level, namespace_, name_='Bound')
        if self.Virtual_Address is not None:
            self.Virtual_Address.export(outfile, level, namespace_, name_='Virtual_Address')
    def hasContent_(self):
        if (
            self.Function_Name is not None or
            self.Hint is not None or
            self.Ordinal is not None or
            self.Bound is not None or
            self.Virtual_Address is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEImportedFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Function_Name is not None:
            showIndent(outfile, level)
            outfile.write('Function_Name=%s,\n' % quote_python(self.Function_Name).encode(ExternalEncoding))
        if self.Hint is not None:
            showIndent(outfile, level)
            outfile.write('Hint=%s,\n' % quote_python(self.Hint).encode(ExternalEncoding))
        if self.Ordinal is not None:
            showIndent(outfile, level)
            outfile.write('Ordinal=%s,\n' % quote_python(self.Ordinal).encode(ExternalEncoding))
        if self.Bound is not None:
            showIndent(outfile, level)
            outfile.write('Bound=%s,\n' % quote_python(self.Bound).encode(ExternalEncoding))
        if self.Virtual_Address is not None:
            showIndent(outfile, level)
            outfile.write('Virtual_Address=%s,\n' % quote_python(self.Virtual_Address).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Function_Name':
            Function_Name_ = common.StringObjectAttributeType.factory()
            Function_Name_.build(child_)
            self.set_Function_Name(Function_Name_)
        elif nodeName_ == 'Hint':
            Hint_ = child_.text
            Hint_ = self.gds_validate_string(Hint_, node, 'Hint')
            self.Hint = Hint_
        elif nodeName_ == 'Ordinal':
            Ordinal_ = child_.text
            Ordinal_ = self.gds_validate_string(Ordinal_, node, 'Ordinal')
            self.Ordinal = Ordinal_
        elif nodeName_ == 'Bound':
            Bound_ = child_.text
            Bound_ = self.gds_validate_string(Bound_, node, 'Bound')
            self.Bound = Bound_
        elif nodeName_ == 'Virtual_Address':
            Virtual_Address_ = child_.text
            Virtual_Address_ = self.gds_validate_string(Virtual_Address_, node, 'Virtual_Address')
            self.Virtual_Address = Virtual_Address_
# end class PEImportedFunctionType


class PEImportListType(GeneratedsSuper):
    """PEImportListType specifies a list of functions in an import data
    section."""
    subclass = None
    superclass = None
    def __init__(self, Import=None):
        if Import is None:
            self.Import = []
        else:
            self.Import = Import
    def factory(*args_, **kwargs_):
        if PEImportListType.subclass:
            return PEImportListType.subclass(*args_, **kwargs_)
        else:
            return PEImportListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Import(self): return self.Import
    def set_Import(self, Import): self.Import = Import
    def add_Import(self, value): self.Import.append(value)
    def insert_Import(self, index, value): self.Import[index] = value
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEImportListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEImportListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEImportListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEImportListType', fromsubclass_=False):
        for Import_ in self.Import:
            Import_.export(outfile, level, namespace_, name_='Import')
    def hasContent_(self):
        if (
            self.Import
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEImportListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Import=[\n')
        level += 1
        for Import_ in self.Import:
            showIndent(outfile, level)
            outfile.write('model_.PEImportType(\n')
            Import_.exportLiteral(outfile, level, name_='PEImportType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Import':
            obj_ = PEImportType.factory()
            obj_.build(child_)
            self.Import.append(obj_)
# end class PEImportListType


class PESectionType(GeneratedsSuper):
    """The PESectionType type is intended as container for the attributes
    relevant to PE binary sections. A PE Section consists of a
    header and data. The PESectionType contains attributes that
    describe the Section Header and metadata computed about the
    section (e.g., hashes, entropy)."""
    subclass = None
    superclass = None
    def __init__(self, Section_Header=None, Data_Hashes=None, Entropy=None, Header_Hashes=None, Type=None):
        self.Section_Header = Section_Header
        self.Data_Hashes = Data_Hashes
        self.Entropy = Entropy
        self.Header_Hashes = Header_Hashes
        self.Type = Type
    def factory(*args_, **kwargs_):
        if PESectionType.subclass:
            return PESectionType.subclass(*args_, **kwargs_)
        else:
            return PESectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Section_Header(self): return self.Section_Header
    def set_Section_Header(self, Section_Header): self.Section_Header = Section_Header
    def get_Data_Hashes(self): return self.Data_Hashes
    def set_Data_Hashes(self, Data_Hashes): self.Data_Hashes = Data_Hashes
    def get_Entropy(self): return self.Entropy
    def set_Entropy(self, Entropy): self.Entropy = Entropy
    def get_Header_Hashes(self): return self.Header_Hashes
    def set_Header_Hashes(self, Header_Hashes): self.Header_Hashes = Header_Hashes
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_SectionType(self, value):
        # Validate type SectionType, a restriction on None.
        pass
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PESectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PESectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PESectionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PESectionType', fromsubclass_=False):
        if self.Section_Header is not None:
            self.Section_Header.export(outfile, level, namespace_, name_='Section_Header')
        if self.Data_Hashes is not None:
            self.Data_Hashes.export(outfile, level, namespace_, name_='Data_Hashes')
        if self.Entropy is not None:
            self.Entropy.export(outfile, level, namespace_, name_='Entropy')
        if self.Header_Hashes is not None:
            self.Header_Hashes.export(outfile, level, namespace_, name_='Header_Hashes')
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type')
    def hasContent_(self):
        if (
            self.Section_Header is not None or
            self.Data_Hashes is not None or
            self.Entropy is not None or
            self.Header_Hashes is not None or
            self.Type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PESectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Section_Header is not None:
            showIndent(outfile, level)
            outfile.write('Section_Header=model_.PESectionHeaderStructType(\n')
            self.Section_Header.exportLiteral(outfile, level, name_='Section_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Data_Hashes is not None:
            showIndent(outfile, level)
            outfile.write('Data_Hashes=%s,\n' % quote_python(self.Data_Hashes).encode(ExternalEncoding))
        if self.Entropy is not None:
            showIndent(outfile, level)
            outfile.write('Entropy=%s,\n' % quote_python(self.Entropy).encode(ExternalEncoding))
        if self.Header_Hashes is not None:
            showIndent(outfile, level)
            outfile.write('Header_Hashes=%s,\n' % quote_python(self.Header_Hashes).encode(ExternalEncoding))
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=model_.SectionType(\n')
            self.Type.exportLiteral(outfile, level, name_='Type')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Section_Header':
            obj_ = PESectionHeaderStructType.factory()
            obj_.build(child_)
            self.set_Section_Header(obj_)
        elif nodeName_ == 'Data_Hashes':
            Data_Hashes_ = child_.text
            Data_Hashes_ = self.gds_validate_string(Data_Hashes_, node, 'Data_Hashes')
            self.Data_Hashes = Data_Hashes_
        elif nodeName_ == 'Entropy':
            Entropy_ = child_.text
            Entropy_ = self.gds_validate_string(Entropy_, node, 'Entropy')
            self.Entropy = Entropy_
        elif nodeName_ == 'Header_Hashes':
            Header_Hashes_ = child_.text
            Header_Hashes_ = self.gds_validate_string(Header_Hashes_, node, 'Header_Hashes')
            self.Header_Hashes = Header_Hashes_
        elif nodeName_ == 'Type':
            obj_ = common.StringObjectAttributeType.factory()
            obj_.build(child_)
            self.set_Type(obj_)
            self.validate_SectionType(self.Type)    # validate type SectionType
# end class PESectionType


class PEDataDirectoryStructType(GeneratedsSuper):
    """The PEDataDirectoryStruct type is intended as container for the
    attributes present in a PE binary's data directory structure."""
    subclass = None
    superclass = None
    def __init__(self, Virtual_Address=None, Size=None):
        self.Virtual_Address = Virtual_Address
        self.Size = Size
    def factory(*args_, **kwargs_):
        if PEDataDirectoryStructType.subclass:
            return PEDataDirectoryStructType.subclass(*args_, **kwargs_)
        else:
            return PEDataDirectoryStructType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Virtual_Address(self): return self.Virtual_Address
    def set_Virtual_Address(self, Virtual_Address): self.Virtual_Address = Virtual_Address
    def get_Size(self): return self.Size
    def set_Size(self, Size): self.Size = Size
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEDataDirectoryStructType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEDataDirectoryStructType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEDataDirectoryStructType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEDataDirectoryStructType', fromsubclass_=False):
        if self.Virtual_Address is not None:
            self.Virtual_Address.export(outfile, level, namespace_, name_='Virtual_Address')
        if self.Size is not None:
            self.Size.export(outfile, level, namespace_, name_='Size')
    def hasContent_(self):
        if (
            self.Virtual_Address is not None or
            self.Size is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEDataDirectoryStructType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Virtual_Address is not None:
            showIndent(outfile, level)
            outfile.write('Virtual_Address=%s,\n' % quote_python(self.Virtual_Address).encode(ExternalEncoding))
        if self.Size is not None:
            showIndent(outfile, level)
            outfile.write('Size=%s,\n' % quote_python(self.Size).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Virtual_Address':
            Virtual_Address_ = child_.text
            Virtual_Address_ = self.gds_validate_string(Virtual_Address_, node, 'Virtual_Address')
            self.Virtual_Address = Virtual_Address_
        elif nodeName_ == 'Size':
            Size_ = child_.text
            Size_ = self.gds_validate_string(Size_, node, 'Size')
            self.Size = Size_
# end class PEDataDirectoryStructType


class PESectionHeaderStructType(GeneratedsSuper):
    """The PESectionHeaderStruct type is intended as container for the
    attributes present in a PE binary's section header structure."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Physical_Address=None, Virtual_Address=None, Size_Of_Raw_Data=None, Pointer_To_Raw_Data=None, Pointer_To_Relocations=None, Pointer_To_Linenumbers=None, Number_Of_Relocations=None, Number_Of_Linenumbers=None, Characteristics=None):
        self.Name = Name
        self.Physical_Address = Physical_Address
        self.Virtual_Address = Virtual_Address
        self.Size_Of_Raw_Data = Size_Of_Raw_Data
        self.Pointer_To_Raw_Data = Pointer_To_Raw_Data
        self.Pointer_To_Relocations = Pointer_To_Relocations
        self.Pointer_To_Linenumbers = Pointer_To_Linenumbers
        self.Number_Of_Relocations = Number_Of_Relocations
        self.Number_Of_Linenumbers = Number_Of_Linenumbers
        self.Characteristics = Characteristics
    def factory(*args_, **kwargs_):
        if PESectionHeaderStructType.subclass:
            return PESectionHeaderStructType.subclass(*args_, **kwargs_)
        else:
            return PESectionHeaderStructType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Physical_Address(self): return self.Physical_Address
    def set_Physical_Address(self, Physical_Address): self.Physical_Address = Physical_Address
    def get_Virtual_Address(self): return self.Virtual_Address
    def set_Virtual_Address(self, Virtual_Address): self.Virtual_Address = Virtual_Address
    def get_Size_Of_Raw_Data(self): return self.Size_Of_Raw_Data
    def set_Size_Of_Raw_Data(self, Size_Of_Raw_Data): self.Size_Of_Raw_Data = Size_Of_Raw_Data
    def get_Pointer_To_Raw_Data(self): return self.Pointer_To_Raw_Data
    def set_Pointer_To_Raw_Data(self, Pointer_To_Raw_Data): self.Pointer_To_Raw_Data = Pointer_To_Raw_Data
    def get_Pointer_To_Relocations(self): return self.Pointer_To_Relocations
    def set_Pointer_To_Relocations(self, Pointer_To_Relocations): self.Pointer_To_Relocations = Pointer_To_Relocations
    def get_Pointer_To_Linenumbers(self): return self.Pointer_To_Linenumbers
    def set_Pointer_To_Linenumbers(self, Pointer_To_Linenumbers): self.Pointer_To_Linenumbers = Pointer_To_Linenumbers
    def get_Number_Of_Relocations(self): return self.Number_Of_Relocations
    def set_Number_Of_Relocations(self, Number_Of_Relocations): self.Number_Of_Relocations = Number_Of_Relocations
    def get_Number_Of_Linenumbers(self): return self.Number_Of_Linenumbers
    def set_Number_Of_Linenumbers(self, Number_Of_Linenumbers): self.Number_Of_Linenumbers = Number_Of_Linenumbers
    def get_Characteristics(self): return self.Characteristics
    def set_Characteristics(self, Characteristics): self.Characteristics = Characteristics
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PESectionHeaderStructType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PESectionHeaderStructType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PESectionHeaderStructType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PESectionHeaderStructType', fromsubclass_=False):
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name')
        if self.Physical_Address is not None:
            self.Physical_Address.export(outfile, level, namespace_, name_='Physical_Address')
        if self.Virtual_Address is not None:
            self.Virtual_Address.export(outfile, level, namespace_, name_='Virtual_Address')
        if self.Size_Of_Raw_Data is not None:
            self.Size_Of_Raw_Data.export(outfile, level, namespace_, name_='Size_Of_Raw_Data')
        if self.Pointer_To_Raw_Data is not None:
            self.Pointer_To_Raw_Data.export(outfile, level, namespace_, name_='Pointer_To_Raw_Data')
        if self.Pointer_To_Relocations is not None:
            self.Pointer_To_Relocations.export(outfile, level, namespace_, name_='Pointer_To_Relocations')
        if self.Pointer_To_Linenumbers is not None:
            self.Pointer_To_Linenumbers.export(outfile, level, namespace_, name_='Pointer_To_Linenumbers')
        if self.Number_Of_Relocations is not None:
            self.Number_Of_Relocations.export(outfile, level, namespace_, name_='Number_Of_Relocations')
        if self.Number_Of_Linenumbers is not None:
            self.Number_Of_Linenumbers.export(outfile, level, namespace_, name_='Number_Of_Linenumbers')
        if self.Characteristics is not None:
            self.Characteristics.export(outfile, level, namespace_, name_='Characteristics')
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Physical_Address is not None or
            self.Virtual_Address is not None or
            self.Size_Of_Raw_Data is not None or
            self.Pointer_To_Raw_Data is not None or
            self.Pointer_To_Relocations is not None or
            self.Pointer_To_Linenumbers is not None or
            self.Number_Of_Relocations is not None or
            self.Number_Of_Linenumbers is not None or
            self.Characteristics is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PESectionHeaderStructType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Physical_Address is not None:
            showIndent(outfile, level)
            outfile.write('Physical_Address=%s,\n' % quote_python(self.Physical_Address).encode(ExternalEncoding))
        if self.Virtual_Address is not None:
            showIndent(outfile, level)
            outfile.write('Virtual_Address=%s,\n' % quote_python(self.Virtual_Address).encode(ExternalEncoding))
        if self.Size_Of_Raw_Data is not None:
            showIndent(outfile, level)
            outfile.write('Size_Of_Raw_Data=%s,\n' % quote_python(self.Size_Of_Raw_Data).encode(ExternalEncoding))
        if self.Pointer_To_Raw_Data is not None:
            showIndent(outfile, level)
            outfile.write('Pointer_To_Raw_Data=%s,\n' % quote_python(self.Pointer_To_Raw_Data).encode(ExternalEncoding))
        if self.Pointer_To_Relocations is not None:
            showIndent(outfile, level)
            outfile.write('Pointer_To_Relocations=%s,\n' % quote_python(self.Pointer_To_Relocations).encode(ExternalEncoding))
        if self.Pointer_To_Linenumbers is not None:
            showIndent(outfile, level)
            outfile.write('Pointer_To_Linenumbers=%s,\n' % quote_python(self.Pointer_To_Linenumbers).encode(ExternalEncoding))
        if self.Number_Of_Relocations is not None:
            showIndent(outfile, level)
            outfile.write('Number_Of_Relocations=%s,\n' % quote_python(self.Number_Of_Relocations).encode(ExternalEncoding))
        if self.Number_Of_Linenumbers is not None:
            showIndent(outfile, level)
            outfile.write('Number_Of_Linenumbers=%s,\n' % quote_python(self.Number_Of_Linenumbers).encode(ExternalEncoding))
        if self.Characteristics is not None:
            showIndent(outfile, level)
            outfile.write('Characteristics=%s,\n' % quote_python(self.Characteristics).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = common.StringObjectAttributeType.factory()
            obj_.build(child_)
            self.set_Name(obj_)
        elif nodeName_ == 'Physical_Address':
            obj_ = common.StringObjectAttributeType.factory()
            obj_.build(child_)
            self.set_Physical_Address(obj_)
        elif nodeName_ == 'Virtual_Address':
            Virtual_Address_ = child_.text
            Virtual_Address_ = self.gds_validate_string(Virtual_Address_, node, 'Virtual_Address')
            self.Virtual_Address = Virtual_Address_
        elif nodeName_ == 'Size_Of_Raw_Data':
            Size_Of_Raw_Data_ = child_.text
            Size_Of_Raw_Data_ = self.gds_validate_string(Size_Of_Raw_Data_, node, 'Size_Of_Raw_Data')
            self.Size_Of_Raw_Data = Size_Of_Raw_Data_
        elif nodeName_ == 'Pointer_To_Raw_Data':
            Pointer_To_Raw_Data_ = child_.text
            Pointer_To_Raw_Data_ = self.gds_validate_string(Pointer_To_Raw_Data_, node, 'Pointer_To_Raw_Data')
            self.Pointer_To_Raw_Data = Pointer_To_Raw_Data_
        elif nodeName_ == 'Pointer_To_Relocations':
            Pointer_To_Relocations_ = child_.text
            Pointer_To_Relocations_ = self.gds_validate_string(Pointer_To_Relocations_, node, 'Pointer_To_Relocations')
            self.Pointer_To_Relocations = Pointer_To_Relocations_
        elif nodeName_ == 'Pointer_To_Linenumbers':
            Pointer_To_Linenumbers_ = child_.text
            Pointer_To_Linenumbers_ = self.gds_validate_string(Pointer_To_Linenumbers_, node, 'Pointer_To_Linenumbers')
            self.Pointer_To_Linenumbers = Pointer_To_Linenumbers_
        elif nodeName_ == 'Number_Of_Relocations':
            Number_Of_Relocations_ = child_.text
            Number_Of_Relocations_ = self.gds_validate_string(Number_Of_Relocations_, node, 'Number_Of_Relocations')
            self.Number_Of_Relocations = Number_Of_Relocations_
        elif nodeName_ == 'Number_Of_Linenumbers':
            Number_Of_Linenumbers_ = child_.text
            Number_Of_Linenumbers_ = self.gds_validate_string(Number_Of_Linenumbers_, node, 'Number_Of_Linenumbers')
            self.Number_Of_Linenumbers = Number_Of_Linenumbers_
        elif nodeName_ == 'Characteristics':
            Characteristics_ = common.HexBinaryObjectAttributeType.factory()
            Characteristics_.build(child_)
            self.set_Characteristics(Characteristics_)
# end class PESectionHeaderStructType


class DOSHeaderType(GeneratedsSuper):
    """The DOSHeaderType type is a container for the attributes present in
    the _IMAGE_DOS_HEADER structure, which can be found in Winnt.h
    and pe.h. See http://www.csn.ul.ie/~caolan/pub/winresdump/winres
    dump/doc/pefile.html for more information about the winnt.h
    file, and http://www.tavi.co.uk/phobos/exeformat.html for even
    more clarification."""
    subclass = None
    superclass = None
    def __init__(self, e_magic=None, e_cblp=None, e_cp=None, e_crlc=None, e_cparhdr=None, e_minalloc=None, e_maxalloc=None, e_ss=None, e_sp=None, e_csum=None, e_ip=None, e_cs=None, e_lfarlc=None, e_ovro=None, reserved1=None, e_oemid=None, e_oeminfo=None, reserved2=None, e_lfanew=None, Hashes=None):
        self.e_magic = e_magic
        self.e_cblp = e_cblp
        self.e_cp = e_cp
        self.e_crlc = e_crlc
        self.e_cparhdr = e_cparhdr
        self.e_minalloc = e_minalloc
        self.e_maxalloc = e_maxalloc
        self.e_ss = e_ss
        self.e_sp = e_sp
        self.e_csum = e_csum
        self.e_ip = e_ip
        self.e_cs = e_cs
        self.e_lfarlc = e_lfarlc
        self.e_ovro = e_ovro
        if reserved1 is None:
            self.reserved1 = []
        else:
            self.reserved1 = reserved1
        self.e_oemid = e_oemid
        self.e_oeminfo = e_oeminfo
        self.reserved2 = reserved2
        self.e_lfanew = e_lfanew
        self.Hashes = Hashes
    def factory(*args_, **kwargs_):
        if DOSHeaderType.subclass:
            return DOSHeaderType.subclass(*args_, **kwargs_)
        else:
            return DOSHeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_e_magic(self): return self.e_magic
    def set_e_magic(self, e_magic): self.e_magic = e_magic
    def get_e_cblp(self): return self.e_cblp
    def set_e_cblp(self, e_cblp): self.e_cblp = e_cblp
    def get_e_cp(self): return self.e_cp
    def set_e_cp(self, e_cp): self.e_cp = e_cp
    def get_e_crlc(self): return self.e_crlc
    def set_e_crlc(self, e_crlc): self.e_crlc = e_crlc
    def get_e_cparhdr(self): return self.e_cparhdr
    def set_e_cparhdr(self, e_cparhdr): self.e_cparhdr = e_cparhdr
    def get_e_minalloc(self): return self.e_minalloc
    def set_e_minalloc(self, e_minalloc): self.e_minalloc = e_minalloc
    def get_e_maxalloc(self): return self.e_maxalloc
    def set_e_maxalloc(self, e_maxalloc): self.e_maxalloc = e_maxalloc
    def get_e_ss(self): return self.e_ss
    def set_e_ss(self, e_ss): self.e_ss = e_ss
    def get_e_sp(self): return self.e_sp
    def set_e_sp(self, e_sp): self.e_sp = e_sp
    def get_e_csum(self): return self.e_csum
    def set_e_csum(self, e_csum): self.e_csum = e_csum
    def get_e_ip(self): return self.e_ip
    def set_e_ip(self, e_ip): self.e_ip = e_ip
    def get_e_cs(self): return self.e_cs
    def set_e_cs(self, e_cs): self.e_cs = e_cs
    def get_e_lfarlc(self): return self.e_lfarlc
    def set_e_lfarlc(self, e_lfarlc): self.e_lfarlc = e_lfarlc
    def get_e_ovro(self): return self.e_ovro
    def set_e_ovro(self, e_ovro): self.e_ovro = e_ovro
    def get_reserved1(self): return self.reserved1
    def set_reserved1(self, reserved1): self.reserved1 = reserved1
    def add_reserved1(self, value): self.reserved1.append(value)
    def insert_reserved1(self, index, value): self.reserved1[index] = value
    def get_e_oemid(self): return self.e_oemid
    def set_e_oemid(self, e_oemid): self.e_oemid = e_oemid
    def get_e_oeminfo(self): return self.e_oeminfo
    def set_e_oeminfo(self, e_oeminfo): self.e_oeminfo = e_oeminfo
    def get_reserved2(self): return self.reserved2
    def set_reserved2(self, reserved2): self.reserved2 = reserved2
    def get_e_lfanew(self): return self.e_lfanew
    def set_e_lfanew(self, e_lfanew): self.e_lfanew = e_lfanew
    def get_Hashes(self): return self.Hashes
    def set_Hashes(self, Hashes): self.Hashes = Hashes
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='DOSHeaderType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DOSHeaderType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='DOSHeaderType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='DOSHeaderType', fromsubclass_=False):
        if self.e_magic is not None:
            self.e_magic.export(outfile, level, namespace_, name_='e_magic')
        if self.e_cblp is not None:
            self.e_cblp.export(outfile, level, namespace_, name_='e_cblp')
        if self.e_cp is not None:
            self.e_cp.export(outfile, level, namespace_, name_='e_cp')
        if self.e_crlc is not None:
            self.e_crlc.export(outfile, level, namespace_, name_='e_crlc')
        if self.e_cparhdr is not None:
            self.e_cparhdr.export(outfile, level, namespace_, name_='e_cparhdr')
        if self.e_minalloc is not None:
            self.e_minalloc.export(outfile, level, namespace_, name_='e_minalloc')
        if self.e_maxalloc is not None:
            self.e_maxalloc.export(outfile, level, namespace_, name_='e_maxalloc')
        if self.e_ss is not None:
            self.e_ss.export(outfile, level, namespace_, name_='e_ss')
        if self.e_sp is not None:
            self.e_sp.export(outfile, level, namespace_, name_='e_sp')
        if self.e_csum is not None:
            self.e_csum.export(outfile, level, namespace_, name_='e_csum')
        if self.e_ip is not None:
            self.e_ip.export(outfile, level, namespace_, name_='e_ip')
        if self.e_cs is not None:
            self.e_cs.export(outfile, level, namespace_, name_='e_cs')
        if self.e_lfarlc is not None:
            self.e_lfarlc.export(outfile, level, namespace_, name_='e_lfarlc')
        if self.e_ovro is not None:
            self.e_ovro.export(outfile, level, namespace_, name_='e_ovro')
        for reserved1_ in self.reserved1:
            reserved1_.export(outfile, level, namespace_, name_='reserved1')
        if self.e_oemid is not None:
            self.e_oemid.export(outfile, level, namespace_, name_='e_oemid')
        if self.e_oeminfo is not None:
            self.e_oeminfo.export(outfile, level, namespace_, name_='Driver_Init')
        if self.reserved2 is not None:
            self.reserved2.export(outfile, level, namespace_, name_='reserved2')
        if self.e_lfanew is not None:
            self.e_lfanew.export(outfile, level, namespace_, name_='e_lfanew')
        if self.Hashes is not None:
            self.Hashes.export(outfile, level, namespace_, name_='Hashes')
    def hasContent_(self):
        if (
            self.e_magic is not None or
            self.e_cblp is not None or
            self.e_cp is not None or
            self.e_crlc is not None or
            self.e_cparhdr is not None or
            self.e_minalloc is not None or
            self.e_maxalloc is not None or
            self.e_ss is not None or
            self.e_sp is not None or
            self.e_csum is not None or
            self.e_ip is not None or
            self.e_cs is not None or
            self.e_lfarlc is not None or
            self.e_ovro is not None or
            self.reserved1 or
            self.e_oemid is not None or
            self.e_oeminfo is not None or
            self.reserved2 is not None or
            self.e_lfanew is not None or
            self.Hashes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DOSHeaderType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.e_magic is not None:
            showIndent(outfile, level)
            outfile.write('e_magic=%s,\n' % quote_python(self.e_magic).encode(ExternalEncoding))
        if self.e_cblp is not None:
            showIndent(outfile, level)
            outfile.write('e_cblp=%s,\n' % quote_python(self.e_cblp).encode(ExternalEncoding))
        if self.e_cp is not None:
            showIndent(outfile, level)
            outfile.write('e_cp=%s,\n' % quote_python(self.e_cp).encode(ExternalEncoding))
        if self.e_crlc is not None:
            showIndent(outfile, level)
            outfile.write('e_crlc=%s,\n' % quote_python(self.e_crlc).encode(ExternalEncoding))
        if self.e_cparhdr is not None:
            showIndent(outfile, level)
            outfile.write('e_cparhdr=%s,\n' % quote_python(self.e_cparhdr).encode(ExternalEncoding))
        if self.e_minalloc is not None:
            showIndent(outfile, level)
            outfile.write('e_minalloc=%s,\n' % quote_python(self.e_minalloc).encode(ExternalEncoding))
        if self.e_maxalloc is not None:
            showIndent(outfile, level)
            outfile.write('e_maxalloc=%s,\n' % quote_python(self.e_maxalloc).encode(ExternalEncoding))
        if self.e_ss is not None:
            showIndent(outfile, level)
            outfile.write('e_ss=%s,\n' % quote_python(self.e_ss).encode(ExternalEncoding))
        if self.e_sp is not None:
            showIndent(outfile, level)
            outfile.write('e_sp=%s,\n' % quote_python(self.e_sp).encode(ExternalEncoding))
        if self.e_csum is not None:
            showIndent(outfile, level)
            outfile.write('e_csum=%s,\n' % quote_python(self.e_csum).encode(ExternalEncoding))
        if self.e_ip is not None:
            showIndent(outfile, level)
            outfile.write('e_ip=%s,\n' % quote_python(self.e_ip).encode(ExternalEncoding))
        if self.e_cs is not None:
            showIndent(outfile, level)
            outfile.write('e_cs=%s,\n' % quote_python(self.e_cs).encode(ExternalEncoding))
        if self.e_lfarlc is not None:
            showIndent(outfile, level)
            outfile.write('e_lfarlc=%s,\n' % quote_python(self.e_lfarlc).encode(ExternalEncoding))
        if self.e_ovro is not None:
            showIndent(outfile, level)
            outfile.write('e_ovro=%s,\n' % quote_python(self.e_ovro).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('reserved1=[\n')
        level += 1
        for reserved1_ in self.reserved1:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(reserved1_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.e_oemid is not None:
            showIndent(outfile, level)
            outfile.write('e_oemid=%s,\n' % quote_python(self.e_oemid).encode(ExternalEncoding))
        if self.e_oeminfo is not None:
            showIndent(outfile, level)
            outfile.write('e_oeminfo=%s,\n' % quote_python(self.e_oeminfo).encode(ExternalEncoding))
        if self.reserved2 is not None:
            showIndent(outfile, level)
            outfile.write('reserved2=%s,\n' % quote_python(self.reserved2).encode(ExternalEncoding))
        if self.e_lfanew is not None:
            showIndent(outfile, level)
            outfile.write('e_lfanew=%s,\n' % quote_python(self.e_lfanew).encode(ExternalEncoding))
        if self.Hashes is not None:
            showIndent(outfile, level)
            outfile.write('Hashes=%s,\n' % quote_python(self.Hashes).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'e_magic':
            e_magic_ = child_.text
            e_magic_ = self.gds_validate_string(e_magic_, node, 'e_magic')
            self.e_magic = e_magic_
        elif nodeName_ == 'e_cblp':
            e_cblp_ = child_.text
            e_cblp_ = self.gds_validate_string(e_cblp_, node, 'e_cblp')
            self.e_cblp = e_cblp_
        elif nodeName_ == 'e_cp':
            e_cp_ = child_.text
            e_cp_ = self.gds_validate_string(e_cp_, node, 'e_cp')
            self.e_cp = e_cp_
        elif nodeName_ == 'e_crlc':
            e_crlc_ = child_.text
            e_crlc_ = self.gds_validate_string(e_crlc_, node, 'e_crlc')
            self.e_crlc = e_crlc_
        elif nodeName_ == 'e_cparhdr':
            e_cparhdr_ = child_.text
            e_cparhdr_ = self.gds_validate_string(e_cparhdr_, node, 'e_cparhdr')
            self.e_cparhdr = e_cparhdr_
        elif nodeName_ == 'e_minalloc':
            e_minalloc_ = child_.text
            e_minalloc_ = self.gds_validate_string(e_minalloc_, node, 'e_minalloc')
            self.e_minalloc = e_minalloc_
        elif nodeName_ == 'e_maxalloc':
            e_maxalloc_ = child_.text
            e_maxalloc_ = self.gds_validate_string(e_maxalloc_, node, 'e_maxalloc')
            self.e_maxalloc = e_maxalloc_
        elif nodeName_ == 'e_ss':
            e_ss_ = child_.text
            e_ss_ = self.gds_validate_string(e_ss_, node, 'e_ss')
            self.e_ss = e_ss_
        elif nodeName_ == 'e_sp':
            e_sp_ = child_.text
            e_sp_ = self.gds_validate_string(e_sp_, node, 'e_sp')
            self.e_sp = e_sp_
        elif nodeName_ == 'e_csum':
            e_csum_ = child_.text
            e_csum_ = self.gds_validate_string(e_csum_, node, 'e_csum')
            self.e_csum = e_csum_
        elif nodeName_ == 'e_ip':
            e_ip_ = child_.text
            e_ip_ = self.gds_validate_string(e_ip_, node, 'e_ip')
            self.e_ip = e_ip_
        elif nodeName_ == 'e_cs':
            e_cs_ = child_.text
            e_cs_ = self.gds_validate_string(e_cs_, node, 'e_cs')
            self.e_cs = e_cs_
        elif nodeName_ == 'e_lfarlc':
            e_lfarlc_ = child_.text
            e_lfarlc_ = self.gds_validate_string(e_lfarlc_, node, 'e_lfarlc')
            self.e_lfarlc = e_lfarlc_
        elif nodeName_ == 'e_ovro':
            e_ovro_ = child_.text
            e_ovro_ = self.gds_validate_string(e_ovro_, node, 'e_ovro')
            self.e_ovro = e_ovro_
        elif nodeName_ == 'reserved1':
            reserved1_ = child_.text
            reserved1_ = self.gds_validate_string(reserved1_, node, 'reserved1')
            self.reserved1.append(reserved1_)
        elif nodeName_ == 'e_oemid':
            e_oemid_ = child_.text
            e_oemid_ = self.gds_validate_string(e_oemid_, node, 'e_oemid')
            self.e_oemid = e_oemid_
        elif nodeName_ == 'e_oeminfo':
            e_oeminfo_ = child_.text
            e_oeminfo_ = self.gds_validate_string(e_oeminfo_, node, 'e_oeminfo')
            self.e_oeminfo = e_oeminfo_
        elif nodeName_ == 'reserved2':
            reserved2_ = child_.text
            reserved2_ = self.gds_validate_string(reserved2_, node, 'reserved2')
            self.reserved2 = reserved2_
        elif nodeName_ == 'e_lfanew':
            e_lfanew_ = child_.text
            e_lfanew_ = self.gds_validate_string(e_lfanew_, node, 'e_lfanew')
            self.e_lfanew = e_lfanew_
        elif nodeName_ == 'Hashes':
            Hashes_ = child_.text
            Hashes_ = self.gds_validate_string(Hashes_, node, 'Hashes')
            self.Hashes = Hashes_
# end class DOSHeaderType


class PEHeadersType(GeneratedsSuper):
    """PEHeaderType specifies the headers found in PE and COFF files."""
    subclass = None
    superclass = None
    def __init__(self, DOS_Header=None, Signature=None, File_Header=None, Optional_Header=None, Entropy=None, Hashes=None):
        self.DOS_Header = DOS_Header
        self.Signature = Signature
        self.File_Header = File_Header
        self.Optional_Header = Optional_Header
        self.Entropy = Entropy
        self.Hashes = Hashes
    def factory(*args_, **kwargs_):
        if PEHeadersType.subclass:
            return PEHeadersType.subclass(*args_, **kwargs_)
        else:
            return PEHeadersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DOS_Header(self): return self.DOS_Header
    def set_DOS_Header(self, DOS_Header): self.DOS_Header = DOS_Header
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_File_Header(self): return self.File_Header
    def set_File_Header(self, File_Header): self.File_Header = File_Header
    def get_Optional_Header(self): return self.Optional_Header
    def set_Optional_Header(self, Optional_Header): self.Optional_Header = Optional_Header
    def get_Entropy(self): return self.Entropy
    def set_Entropy(self, Entropy): self.Entropy = Entropy
    def get_Hashes(self): return self.Hashes
    def set_Hashes(self, Hashes): self.Hashes = Hashes
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEHeadersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEHeadersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEHeadersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEHeadersType', fromsubclass_=False):
        if self.DOS_Header is not None:
            self.DOS_Header.export(outfile, level, namespace_, name_='DOS_Header')
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespace_, name_='Signature')
        if self.File_Header is not None:
            self.File_Header.export(outfile, level, namespace_, name_='File_Header')
        if self.Optional_Header is not None:
            self.Optional_Header.export(outfile, level, namespace_, name_='Optional_Header')
        if self.Entropy is not None:
            self.Entropy.export(outfile, level, namespace_, name_='Entropy')
        if self.Hashes is not None:
            self.Hashes.export(outfile, level, namespace_, name_='Hashes')
    def hasContent_(self):
        if (
            self.DOS_Header is not None or
            self.Signature is not None or
            self.File_Header is not None or
            self.Optional_Header is not None or
            self.Entropy is not None or
            self.Hashes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEHeadersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DOS_Header is not None:
            showIndent(outfile, level)
            outfile.write('DOS_Header=model_.DOSHeaderType(\n')
            self.DOS_Header.exportLiteral(outfile, level, name_='DOS_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=%s,\n' % quote_python(self.Signature).encode(ExternalEncoding))
        if self.File_Header is not None:
            showIndent(outfile, level)
            outfile.write('File_Header=model_.PEFileHeaderType(\n')
            self.File_Header.exportLiteral(outfile, level, name_='File_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Optional_Header is not None:
            showIndent(outfile, level)
            outfile.write('Optional_Header=model_.PEOptionalHeaderType(\n')
            self.Optional_Header.exportLiteral(outfile, level, name_='Optional_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Entropy is not None:
            showIndent(outfile, level)
            outfile.write('Entropy=%s,\n' % quote_python(self.Entropy).encode(ExternalEncoding))
        if self.Hashes is not None:
            showIndent(outfile, level)
            outfile.write('Hashes=%s,\n' % quote_python(self.Hashes).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DOS_Header':
            obj_ = DOSHeaderType.factory()
            obj_.build(child_)
            self.set_DOS_Header(obj_)
        elif nodeName_ == 'Signature':
            Signature_ = child_.text
            Signature_ = self.gds_validate_string(Signature_, node, 'Signature')
            self.Signature = Signature_
        elif nodeName_ == 'File_Header':
            obj_ = PEFileHeaderType.factory()
            obj_.build(child_)
            self.set_File_Header(obj_)
        elif nodeName_ == 'Optional_Header':
            obj_ = PEOptionalHeaderType.factory()
            obj_.build(child_)
            self.set_Optional_Header(obj_)
        elif nodeName_ == 'Entropy':
            Entropy_ = child_.text
            Entropy_ = self.gds_validate_string(Entropy_, node, 'Entropy')
            self.Entropy = Entropy_
        elif nodeName_ == 'Hashes':
            Hashes_ = child_.text
            Hashes_ = self.gds_validate_string(Hashes_, node, 'Hashes')
            self.Hashes = Hashes_
# end class PEHeadersType


class PEFileHeaderType(GeneratedsSuper):
    """The PEFileHeaderType type refers to the PE file header (somtimes
    referred to as the COFF header) and its associated attributes."""
    subclass = None
    superclass = None
    def __init__(self, Machine=None, Number_Of_Sections=None, Time_Date_Stamp=None, Pointer_To_Symbol_Table=None, Number_Of_Symbols=None, Size_Of_Optional_Header=None, Characteristics=None, Hashes=None):
        self.Machine = Machine
        self.Number_Of_Sections = Number_Of_Sections
        self.Time_Date_Stamp = Time_Date_Stamp
        self.Pointer_To_Symbol_Table = Pointer_To_Symbol_Table
        self.Number_Of_Symbols = Number_Of_Symbols
        self.Size_Of_Optional_Header = Size_Of_Optional_Header
        self.Characteristics = Characteristics
        self.Hashes = Hashes
    def factory(*args_, **kwargs_):
        if PEFileHeaderType.subclass:
            return PEFileHeaderType.subclass(*args_, **kwargs_)
        else:
            return PEFileHeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Machine(self): return self.Machine
    def set_Machine(self, Machine): self.Machine = Machine
    def get_Number_Of_Sections(self): return self.Number_Of_Sections
    def set_Number_Of_Sections(self, Number_Of_Sections): self.Number_Of_Sections = Number_Of_Sections
    def get_Time_Date_Stamp(self): return self.Time_Date_Stamp
    def set_Time_Date_Stamp(self, Time_Date_Stamp): self.Time_Date_Stamp = Time_Date_Stamp
    def get_Pointer_To_Symbol_Table(self): return self.Pointer_To_Symbol_Table
    def set_Pointer_To_Symbol_Table(self, Pointer_To_Symbol_Table): self.Pointer_To_Symbol_Table = Pointer_To_Symbol_Table
    def get_Number_Of_Symbols(self): return self.Number_Of_Symbols
    def set_Number_Of_Symbols(self, Number_Of_Symbols): self.Number_Of_Symbols = Number_Of_Symbols
    def get_Size_Of_Optional_Header(self): return self.Size_Of_Optional_Header
    def set_Size_Of_Optional_Header(self, Size_Of_Optional_Header): self.Size_Of_Optional_Header = Size_Of_Optional_Header
    def get_Characteristics(self): return self.Characteristics
    def set_Characteristics(self, Characteristics): self.Characteristics = Characteristics
    def get_Hashes(self): return self.Hashes
    def set_Hashes(self, Hashes): self.Hashes = Hashes
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEFileHeaderType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEFileHeaderType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEFileHeaderType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEFileHeaderType', fromsubclass_=False):
        if self.Machine is not None:
            self.Machine.export(outfile, level, namespace_, name_='Machine')
        if self.Number_Of_Sections is not None:
            self.Number_Of_Sections.export(outfile, level, namespace_, name_='Number_Of_Sections')
        if self.Time_Date_Stamp is not None:
            self.Time_Date_Stamp.export(outfile, level, namespace_, name_='Time_Date_Stamp')
        if self.Pointer_To_Symbol_Table is not None:
            self.Pointer_To_Symbol_Table.export(outfile, level, namespace_, name_='Pointer_To_Symbol_Table')
        if self.Number_Of_Symbols is not None:
            self.Number_Of_Symbols.export(outfile, level, namespace_, name_='Number_Of_Symbols')
        if self.Size_Of_Optional_Header is not None:
            self.Size_Of_Optional_Header.export(outfile, level, namespace_, name_='Size_Of_Optional_Header')
        if self.Characteristics is not None:
            self.Characteristics.export(outfile, level, namespace_, name_='Characteristics')
        if self.Hashes is not None:
            self.Hashes.export(outfile, level, namespace_, name_='Hashes')
    def hasContent_(self):
        if (
            self.Machine is not None or
            self.Number_Of_Sections is not None or
            self.Time_Date_Stamp is not None or
            self.Pointer_To_Symbol_Table is not None or
            self.Number_Of_Symbols is not None or
            self.Size_Of_Optional_Header is not None or
            self.Characteristics is not None or
            self.Hashes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEFileHeaderType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Machine is not None:
            showIndent(outfile, level)
            outfile.write('Machine=%s,\n' % quote_python(self.Machine).encode(ExternalEncoding))
        if self.Number_Of_Sections is not None:
            showIndent(outfile, level)
            outfile.write('Number_Of_Sections=%s,\n' % quote_python(self.Number_Of_Sections).encode(ExternalEncoding))
        if self.Time_Date_Stamp is not None:
            showIndent(outfile, level)
            outfile.write('Time_Date_Stamp=%s,\n' % quote_python(self.Time_Date_Stamp).encode(ExternalEncoding))
        if self.Pointer_To_Symbol_Table is not None:
            showIndent(outfile, level)
            outfile.write('Pointer_To_Symbol_Table=%s,\n' % quote_python(self.Pointer_To_Symbol_Table).encode(ExternalEncoding))
        if self.Number_Of_Symbols is not None:
            showIndent(outfile, level)
            outfile.write('Number_Of_Symbols=%s,\n' % quote_python(self.Number_Of_Symbols).encode(ExternalEncoding))
        if self.Size_Of_Optional_Header is not None:
            showIndent(outfile, level)
            outfile.write('Size_Of_Optional_Header=%s,\n' % quote_python(self.Size_Of_Optional_Header).encode(ExternalEncoding))
        if self.Characteristics is not None:
            showIndent(outfile, level)
            outfile.write('Characteristics=%s,\n' % quote_python(self.Characteristics).encode(ExternalEncoding))
        if self.Hashes is not None:
            showIndent(outfile, level)
            outfile.write('Hashes=%s,\n' % quote_python(self.Hashes).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Machine':
            Machine_ = child_.text
            Machine_ = self.gds_validate_string(Machine_, node, 'Machine')
            self.Machine = Machine_
        elif nodeName_ == 'Number_Of_Sections':
            Number_Of_Sections_ = child_.text
            Number_Of_Sections_ = self.gds_validate_string(Number_Of_Sections_, node, 'Number_Of_Sections')
            self.Number_Of_Sections = Number_Of_Sections_
        elif nodeName_ == 'Time_Date_Stamp':
            Time_Date_Stamp_ = child_.text
            Time_Date_Stamp_ = self.gds_validate_string(Time_Date_Stamp_, node, 'Time_Date_Stamp')
            self.Time_Date_Stamp = Time_Date_Stamp_
        elif nodeName_ == 'Pointer_To_Symbol_Table':
            Pointer_To_Symbol_Table_ = child_.text
            Pointer_To_Symbol_Table_ = self.gds_validate_string(Pointer_To_Symbol_Table_, node, 'Pointer_To_Symbol_Table')
            self.Pointer_To_Symbol_Table = Pointer_To_Symbol_Table_
        elif nodeName_ == 'Number_Of_Symbols':
            Number_Of_Symbols_ = child_.text
            Number_Of_Symbols_ = self.gds_validate_string(Number_Of_Symbols_, node, 'Number_Of_Symbols')
            self.Number_Of_Symbols = Number_Of_Symbols_
        elif nodeName_ == 'Size_Of_Optional_Header':
            Size_Of_Optional_Header_ = child_.text
            Size_Of_Optional_Header_ = self.gds_validate_string(Size_Of_Optional_Header_, node, 'Size_Of_Optional_Header')
            self.Size_Of_Optional_Header = Size_Of_Optional_Header_
        elif nodeName_ == 'Characteristics':
            Characteristics_ = child_.text
            Characteristics_ = self.gds_validate_string(Characteristics_, node, 'Characteristics')
            self.Characteristics = Characteristics_
        elif nodeName_ == 'Hashes':
            Hashes_ = child_.text
            Hashes_ = self.gds_validate_string(Hashes_, node, 'Hashes')
            self.Hashes = Hashes_
# end class PEFileHeaderType


class SubsystemType(GeneratedsSuper):
    """SubsystemTypes specifies subsystem types via a union of the
    SubsystemTypeEnum type and the atomic xs:string type. Its base
    type is the CybOX Core BaseObjectAttributeType, for permitting
    complex (i.e. regular-expression based) specifications.This
    attribute is optional and specifies the expected type for the
    value of the specified element."""
    subclass = None
    superclass = None
    def __init__(self, datatype=None, valueOf_=None):
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SubsystemType.subclass:
            return SubsystemType.subclass(*args_, **kwargs_)
        else:
            return SubsystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='SubsystemType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubsystemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='SubsystemType'):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='SubsystemType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubsystemType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            self.datatype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SubsystemType


class DetectedType(GeneratedsSuper):
    """DetectedType specifies the type of entrypoint that was detected via
    a union of the DetectedTypeEnum type and the atomic xs:string
    type. Its base type is the CybOX Core BaseObjectAttributeType,
    for permitting complex (i.e. regular-expression based)
    specifications.This attribute is optional and specifies the
    expected type for the value of the specified element."""
    subclass = None
    superclass = None
    def __init__(self, datatype=None, valueOf_=None):
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DetectedType.subclass:
            return DetectedType.subclass(*args_, **kwargs_)
        else:
            return DetectedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='DetectedType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DetectedType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='DetectedType'):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='DetectedType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DetectedType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            self.datatype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DetectedType


class PEType(GeneratedsSuper):
    """PEType specifies PE file types via a union of the PETypeEnum type
    and the atomic xs:string type. Its base type is the CybOX Core
    BaseObjectAttributeType, for permitting complex (i.e. regular-
    expression based) specifications.This attribute is optional and
    specifies the expected type for the value of the specified
    element."""
    subclass = None
    superclass = None
    def __init__(self, datatype=None, valueOf_=None):
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PEType.subclass:
            return PEType.subclass(*args_, **kwargs_)
        else:
            return PEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEType'):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            self.datatype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PEType


class SectionType(GeneratedsSuper):
    """SectionTypes specifies PE section types via a union of the
    SectionTypeEnum type and the atomic xs:string type. Its base
    type is the CybOX Core BaseObjectAttributeType, for permitting
    complex (i.e. regular-expression based) specifications.This
    attribute is optional and specifies the expected type for the
    value of the specified element."""
    subclass = None
    superclass = None
    def __init__(self, datatype=None, valueOf_=None):
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SectionType.subclass:
            return SectionType.subclass(*args_, **kwargs_)
        else:
            return SectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='SectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SectionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='SectionType'):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='SectionType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.append('datatype')
            self.datatype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SectionType


class PEOptionalHeaderType(GeneratedsSuper):
    """The PEOptionalHeaderType type describes the PE Optional Header
    structure. Additional computed metadata, e.g., hashes of the
    header, are also included."""
    subclass = None
    superclass = None
    def __init__(self, Magic=None, Major_Linker_Version=None, Minor_Linker_Version=None, Size_Of_Code=None, Size_Of_Initialized_Data=None, Size_Of_Uninitialized_Data=None, Address_Of_Entry_Point=None, Base_Of_Code=None, Base_Of_Data=None, Image_Base=None, Section_Alignment=None, File_Alignment=None, Major_OS_Version=None, Minor_OS_Version=None, Major_Image_Version=None, Minor_Image_Version=None, Major_Subsystem_Version=None, Minor_Subsystem_Version=None, Win32_Version_Value=None, Size_Of_Image=None, Size_Of_Headers=None, Checksum=None, Subsystem=None, DLL_Characteristics=None, Size_Of_Stack_Reserve=None, Size_Of_Stack_Commit=None, Size_Of_Heap_Reserve=None, Size_Of_Heap_Commit=None, Loader_Flags=None, Number_Of_Rva_And_Sizes=None, Data_Directory=None, Hashes=None):
        self.Magic = Magic
        self.Major_Linker_Version = Major_Linker_Version
        self.Minor_Linker_Version = Minor_Linker_Version
        self.Size_Of_Code = Size_Of_Code
        self.Size_Of_Initialized_Data = Size_Of_Initialized_Data
        self.Size_Of_Uninitialized_Data = Size_Of_Uninitialized_Data
        self.Address_Of_Entry_Point = Address_Of_Entry_Point
        self.Base_Of_Code = Base_Of_Code
        self.Base_Of_Data = Base_Of_Data
        self.Image_Base = Image_Base
        self.Section_Alignment = Section_Alignment
        self.File_Alignment = File_Alignment
        self.Major_OS_Version = Major_OS_Version
        self.Minor_OS_Version = Minor_OS_Version
        self.Major_Image_Version = Major_Image_Version
        self.Minor_Image_Version = Minor_Image_Version
        self.Major_Subsystem_Version = Major_Subsystem_Version
        self.Minor_Subsystem_Version = Minor_Subsystem_Version
        self.Win32_Version_Value = Win32_Version_Value
        self.Size_Of_Image = Size_Of_Image
        self.Size_Of_Headers = Size_Of_Headers
        self.Checksum = Checksum
        self.Subsystem = Subsystem
        self.DLL_Characteristics = DLL_Characteristics
        self.Size_Of_Stack_Reserve = Size_Of_Stack_Reserve
        self.Size_Of_Stack_Commit = Size_Of_Stack_Commit
        self.Size_Of_Heap_Reserve = Size_Of_Heap_Reserve
        self.Size_Of_Heap_Commit = Size_Of_Heap_Commit
        self.Loader_Flags = Loader_Flags
        self.Number_Of_Rva_And_Sizes = Number_Of_Rva_And_Sizes
        self.Data_Directory = Data_Directory
        self.Hashes = Hashes
    def factory(*args_, **kwargs_):
        if PEOptionalHeaderType.subclass:
            return PEOptionalHeaderType.subclass(*args_, **kwargs_)
        else:
            return PEOptionalHeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Magic(self): return self.Magic
    def set_Magic(self, Magic): self.Magic = Magic
    def get_Major_Linker_Version(self): return self.Major_Linker_Version
    def set_Major_Linker_Version(self, Major_Linker_Version): self.Major_Linker_Version = Major_Linker_Version
    def get_Minor_Linker_Version(self): return self.Minor_Linker_Version
    def set_Minor_Linker_Version(self, Minor_Linker_Version): self.Minor_Linker_Version = Minor_Linker_Version
    def get_Size_Of_Code(self): return self.Size_Of_Code
    def set_Size_Of_Code(self, Size_Of_Code): self.Size_Of_Code = Size_Of_Code
    def get_Size_Of_Initialized_Data(self): return self.Size_Of_Initialized_Data
    def set_Size_Of_Initialized_Data(self, Size_Of_Initialized_Data): self.Size_Of_Initialized_Data = Size_Of_Initialized_Data
    def get_Size_Of_Uninitialized_Data(self): return self.Size_Of_Uninitialized_Data
    def set_Size_Of_Uninitialized_Data(self, Size_Of_Uninitialized_Data): self.Size_Of_Uninitialized_Data = Size_Of_Uninitialized_Data
    def get_Address_Of_Entry_Point(self): return self.Address_Of_Entry_Point
    def set_Address_Of_Entry_Point(self, Address_Of_Entry_Point): self.Address_Of_Entry_Point = Address_Of_Entry_Point
    def get_Base_Of_Code(self): return self.Base_Of_Code
    def set_Base_Of_Code(self, Base_Of_Code): self.Base_Of_Code = Base_Of_Code
    def get_Base_Of_Data(self): return self.Base_Of_Data
    def set_Base_Of_Data(self, Base_Of_Data): self.Base_Of_Data = Base_Of_Data
    def get_Image_Base(self): return self.Image_Base
    def set_Image_Base(self, Image_Base): self.Image_Base = Image_Base
    def get_Section_Alignment(self): return self.Section_Alignment
    def set_Section_Alignment(self, Section_Alignment): self.Section_Alignment = Section_Alignment
    def get_File_Alignment(self): return self.File_Alignment
    def set_File_Alignment(self, File_Alignment): self.File_Alignment = File_Alignment
    def get_Major_OS_Version(self): return self.Major_OS_Version
    def set_Major_OS_Version(self, Major_OS_Version): self.Major_OS_Version = Major_OS_Version
    def get_Minor_OS_Version(self): return self.Minor_OS_Version
    def set_Minor_OS_Version(self, Minor_OS_Version): self.Minor_OS_Version = Minor_OS_Version
    def get_Major_Image_Version(self): return self.Major_Image_Version
    def set_Major_Image_Version(self, Major_Image_Version): self.Major_Image_Version = Major_Image_Version
    def get_Minor_Image_Version(self): return self.Minor_Image_Version
    def set_Minor_Image_Version(self, Minor_Image_Version): self.Minor_Image_Version = Minor_Image_Version
    def get_Major_Subsystem_Version(self): return self.Major_Subsystem_Version
    def set_Major_Subsystem_Version(self, Major_Subsystem_Version): self.Major_Subsystem_Version = Major_Subsystem_Version
    def get_Minor_Subsystem_Version(self): return self.Minor_Subsystem_Version
    def set_Minor_Subsystem_Version(self, Minor_Subsystem_Version): self.Minor_Subsystem_Version = Minor_Subsystem_Version
    def get_Win32_Version_Value(self): return self.Win32_Version_Value
    def set_Win32_Version_Value(self, Win32_Version_Value): self.Win32_Version_Value = Win32_Version_Value
    def get_Size_Of_Image(self): return self.Size_Of_Image
    def set_Size_Of_Image(self, Size_Of_Image): self.Size_Of_Image = Size_Of_Image
    def get_Size_Of_Headers(self): return self.Size_Of_Headers
    def set_Size_Of_Headers(self, Size_Of_Headers): self.Size_Of_Headers = Size_Of_Headers
    def get_Checksum(self): return self.Checksum
    def set_Checksum(self, Checksum): self.Checksum = Checksum
    def get_Subsystem(self): return self.Subsystem
    def set_Subsystem(self, Subsystem): self.Subsystem = Subsystem
    def get_DLL_Characteristics(self): return self.DLL_Characteristics
    def set_DLL_Characteristics(self, DLL_Characteristics): self.DLL_Characteristics = DLL_Characteristics
    def get_Size_Of_Stack_Reserve(self): return self.Size_Of_Stack_Reserve
    def set_Size_Of_Stack_Reserve(self, Size_Of_Stack_Reserve): self.Size_Of_Stack_Reserve = Size_Of_Stack_Reserve
    def get_Size_Of_Stack_Commit(self): return self.Size_Of_Stack_Commit
    def set_Size_Of_Stack_Commit(self, Size_Of_Stack_Commit): self.Size_Of_Stack_Commit = Size_Of_Stack_Commit
    def get_Size_Of_Heap_Reserve(self): return self.Size_Of_Heap_Reserve
    def set_Size_Of_Heap_Reserve(self, Size_Of_Heap_Reserve): self.Size_Of_Heap_Reserve = Size_Of_Heap_Reserve
    def get_Size_Of_Heap_Commit(self): return self.Size_Of_Heap_Commit
    def set_Size_Of_Heap_Commit(self, Size_Of_Heap_Commit): self.Size_Of_Heap_Commit = Size_Of_Heap_Commit
    def get_Loader_Flags(self): return self.Loader_Flags
    def set_Loader_Flags(self, Loader_Flags): self.Loader_Flags = Loader_Flags
    def get_Number_Of_Rva_And_Sizes(self): return self.Number_Of_Rva_And_Sizes
    def set_Number_Of_Rva_And_Sizes(self, Number_Of_Rva_And_Sizes): self.Number_Of_Rva_And_Sizes = Number_Of_Rva_And_Sizes
    def get_Data_Directory(self): return self.Data_Directory
    def set_Data_Directory(self, Data_Directory): self.Data_Directory = Data_Directory
    def get_Hashes(self): return self.Hashes
    def set_Hashes(self, Hashes): self.Hashes = Hashes
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEOptionalHeaderType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEOptionalHeaderType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='PEOptionalHeaderType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='PEOptionalHeaderType', fromsubclass_=False):
        if self.Magic is not None:
            self.Magic.export(outfile, level, namespace_, name_='Magic')
        if self.Major_Linker_Version is not None:
            self.Major_Linker_Version.export(outfile, level, namespace_, name_='Major_Linker_Version')
        if self.Minor_Linker_Version is not None:
            self.Minor_Linker_Version.export(outfile, level, namespace_, name_='Minor_Linker_Version')
        if self.Size_Of_Code is not None:
            self.Size_Of_Code.export(outfile, level, namespace_, name_='Size_Of_Code')
        if self.Size_Of_Initialized_Data is not None:
            self.Size_Of_Initialized_Data.export(outfile, level, namespace_, name_='Size_Of_Initialized_Data')
        if self.Size_Of_Uninitialized_Data is not None:
            self.Size_Of_Uninitialized_Data.export(outfile, level, namespace_, name_='Size_Of_Uninitialized_Data')
        if self.Address_Of_Entry_Point is not None:
            self.Address_Of_Entry_Point.export(outfile, level, namespace_, name_='Address_Of_Entry_Point')
        if self.Base_Of_Code is not None:
            self.Base_Of_Code.export(outfile, level, namespace_, name_='Base_Of_Code')
        if self.Base_Of_Data is not None:
            self.Base_Of_Data.export(outfile, level, namespace_, name_='Base_Of_Data')
        if self.Image_Base is not None:
            self.Image_Base.export(outfile, level, namespace_, name_='Image_Base')
        if self.Section_Alignment is not None:
            self.Section_Alignment.export(outfile, level, namespace_, name_='Section_Alignment')
        if self.File_Alignment is not None:
            self.File_Alignment.export(outfile, level, namespace_, name_='File_Alignment')
        if self.Major_OS_Version is not None:
            self.Major_OS_Version.export(outfile, level, namespace_, name_='Major_OS_Version')
        if self.Minor_OS_Version is not None:
            self.Minor_OS_Version.export(outfile, level, namespace_, name_='Minor_OS_Version')
        if self.Major_Image_Version is not None:
            self.Major_Image_Version.export(outfile, level, namespace_, name_='Major_Image_Version')
        if self.Minor_Image_Version is not None:
            self.Minor_Image_Version.export(outfile, level, namespace_, name_='Minor_Image_Version')
        if self.Major_Subsystem_Version is not None:
            self.Major_Subsystem_Version.export(outfile, level, namespace_, name_='Major_Subsystem_Version')
        if self.Minor_Subsystem_Version is not None:
            self.Minor_Subsystem_Version.export(outfile, level, namespace_, name_='Minor_Subsystem_Version')
        if self.Win32_Version_Value is not None:
            self.Win32_Version_Value.export(outfile, level, namespace_, name_='Win32_Version_Value')
        if self.Size_Of_Image is not None:
            self.Size_Of_Image.export(outfile, level, namespace_, name_='Size_Of_Image')
        if self.Size_Of_Headers is not None:
            self.Size_Of_Headers.export(outfile, level, namespace_, name_='Size_Of_Headers')
        if self.Checksum is not None:
            self.Checksum.export(outfile, level, namespace_, name_='Checksum')
        if self.Subsystem is not None:
            self.Subsystem.export(outfile, level, namespace_, name_='Subsystem')
        if self.DLL_Characteristics is not None:
            self.DLL_Characteristics.export(outfile, level, namespace_, name_='DLL_Characteristics')
        if self.Size_Of_Stack_Reserve is not None:
            self.Size_Of_Stack_Reserve.export(outfile, level, namespace_, name_='Size_Of_Stack_Reserve')
        if self.Size_Of_Stack_Commit is not None:
            self.Size_Of_Stack_Commit.export(outfile, level, namespace_, name_='Size_Of_Stack_Commit')
        if self.Size_Of_Heap_Reserve is not None:
            self.Size_Of_Heap_Reserve.export(outfile, level, namespace_, name_='Size_Of_Heap_Reserve')
        if self.Size_Of_Heap_Commit is not None:
            self.Size_Of_Heap_Commit.export(outfile, level, namespace_, name_='Size_Of_Heap_Commit')
        if self.Loader_Flags is not None:
            self.Loader_Flags.export(outfile, level, namespace_, name_='Loader_Flags')
        if self.Number_Of_Rva_And_Sizes is not None:
            self.Number_Of_Rva_And_Sizes.export(outfile, level, namespace_, name_='Number_Of_Rva_And_Sizes')
        if self.Data_Directory is not None:
            self.Data_Directory.export(outfile, level, namespace_, name_='Data_Directory')
        if self.Hashes is not None:
            self.Hashes.export(outfile, level, namespace_, name_='Hashes')
    def hasContent_(self):
        if (
            self.Magic is not None or
            self.Major_Linker_Version is not None or
            self.Minor_Linker_Version is not None or
            self.Size_Of_Code is not None or
            self.Size_Of_Initialized_Data is not None or
            self.Size_Of_Uninitialized_Data is not None or
            self.Address_Of_Entry_Point is not None or
            self.Base_Of_Code is not None or
            self.Base_Of_Data is not None or
            self.Image_Base is not None or
            self.Section_Alignment is not None or
            self.File_Alignment is not None or
            self.Major_OS_Version is not None or
            self.Minor_OS_Version is not None or
            self.Major_Image_Version is not None or
            self.Minor_Image_Version is not None or
            self.Major_Subsystem_Version is not None or
            self.Minor_Subsystem_Version is not None or
            self.Win32_Version_Value is not None or
            self.Size_Of_Image is not None or
            self.Size_Of_Headers is not None or
            self.Checksum is not None or
            self.Subsystem is not None or
            self.DLL_Characteristics is not None or
            self.Size_Of_Stack_Reserve is not None or
            self.Size_Of_Stack_Commit is not None or
            self.Size_Of_Heap_Reserve is not None or
            self.Size_Of_Heap_Commit is not None or
            self.Loader_Flags is not None or
            self.Number_Of_Rva_And_Sizes is not None or
            self.Data_Directory is not None or
            self.Hashes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PEOptionalHeaderType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Magic is not None:
            showIndent(outfile, level)
            outfile.write('Magic=%s,\n' % quote_python(self.Magic).encode(ExternalEncoding))
        if self.Major_Linker_Version is not None:
            showIndent(outfile, level)
            outfile.write('Major_Linker_Version=%s,\n' % quote_python(self.Major_Linker_Version).encode(ExternalEncoding))
        if self.Minor_Linker_Version is not None:
            showIndent(outfile, level)
            outfile.write('Minor_Linker_Version=%s,\n' % quote_python(self.Minor_Linker_Version).encode(ExternalEncoding))
        if self.Size_Of_Code is not None:
            showIndent(outfile, level)
            outfile.write('Size_Of_Code=%s,\n' % quote_python(self.Size_Of_Code).encode(ExternalEncoding))
        if self.Size_Of_Initialized_Data is not None:
            showIndent(outfile, level)
            outfile.write('Size_Of_Initialized_Data=%s,\n' % quote_python(self.Size_Of_Initialized_Data).encode(ExternalEncoding))
        if self.Size_Of_Uninitialized_Data is not None:
            showIndent(outfile, level)
            outfile.write('Size_Of_Uninitialized_Data=%s,\n' % quote_python(self.Size_Of_Uninitialized_Data).encode(ExternalEncoding))
        if self.Address_Of_Entry_Point is not None:
            showIndent(outfile, level)
            outfile.write('Address_Of_Entry_Point=%s,\n' % quote_python(self.Address_Of_Entry_Point).encode(ExternalEncoding))
        if self.Base_Of_Code is not None:
            showIndent(outfile, level)
            outfile.write('Base_Of_Code=%s,\n' % quote_python(self.Base_Of_Code).encode(ExternalEncoding))
        if self.Base_Of_Data is not None:
            showIndent(outfile, level)
            outfile.write('Base_Of_Data=%s,\n' % quote_python(self.Base_Of_Data).encode(ExternalEncoding))
        if self.Image_Base is not None:
            showIndent(outfile, level)
            outfile.write('Image_Base=%s,\n' % quote_python(self.Image_Base).encode(ExternalEncoding))
        if self.Section_Alignment is not None:
            showIndent(outfile, level)
            outfile.write('Section_Alignment=%s,\n' % quote_python(self.Section_Alignment).encode(ExternalEncoding))
        if self.File_Alignment is not None:
            showIndent(outfile, level)
            outfile.write('File_Alignment=%s,\n' % quote_python(self.File_Alignment).encode(ExternalEncoding))
        if self.Major_OS_Version is not None:
            showIndent(outfile, level)
            outfile.write('Major_OS_Version=%s,\n' % quote_python(self.Major_OS_Version).encode(ExternalEncoding))
        if self.Minor_OS_Version is not None:
            showIndent(outfile, level)
            outfile.write('Minor_OS_Version=%s,\n' % quote_python(self.Minor_OS_Version).encode(ExternalEncoding))
        if self.Major_Image_Version is not None:
            showIndent(outfile, level)
            outfile.write('Major_Image_Version=%s,\n' % quote_python(self.Major_Image_Version).encode(ExternalEncoding))
        if self.Minor_Image_Version is not None:
            showIndent(outfile, level)
            outfile.write('Minor_Image_Version=%s,\n' % quote_python(self.Minor_Image_Version).encode(ExternalEncoding))
        if self.Major_Subsystem_Version is not None:
            showIndent(outfile, level)
            outfile.write('Major_Subsystem_Version=%s,\n' % quote_python(self.Major_Subsystem_Version).encode(ExternalEncoding))
        if self.Minor_Subsystem_Version is not None:
            showIndent(outfile, level)
            outfile.write('Minor_Subsystem_Version=%s,\n' % quote_python(self.Minor_Subsystem_Version).encode(ExternalEncoding))
        if self.Win32_Version_Value is not None:
            showIndent(outfile, level)
            outfile.write('Win32_Version_Value=%s,\n' % quote_python(self.Win32_Version_Value).encode(ExternalEncoding))
        if self.Size_Of_Image is not None:
            showIndent(outfile, level)
            outfile.write('Size_Of_Image=%s,\n' % quote_python(self.Size_Of_Image).encode(ExternalEncoding))
        if self.Size_Of_Headers is not None:
            showIndent(outfile, level)
            outfile.write('Size_Of_Headers=%s,\n' % quote_python(self.Size_Of_Headers).encode(ExternalEncoding))
        if self.Checksum is not None:
            showIndent(outfile, level)
            outfile.write('Checksum=%s,\n' % quote_python(self.Checksum).encode(ExternalEncoding))
        if self.Subsystem is not None:
            showIndent(outfile, level)
            outfile.write('Subsystem=%s,\n' % quote_python(self.Subsystem).encode(ExternalEncoding))
        if self.DLL_Characteristics is not None:
            showIndent(outfile, level)
            outfile.write('DLL_Characteristics=%s,\n' % quote_python(self.DLL_Characteristics).encode(ExternalEncoding))
        if self.Size_Of_Stack_Reserve is not None:
            showIndent(outfile, level)
            outfile.write('Size_Of_Stack_Reserve=%s,\n' % quote_python(self.Size_Of_Stack_Reserve).encode(ExternalEncoding))
        if self.Size_Of_Stack_Commit is not None:
            showIndent(outfile, level)
            outfile.write('Size_Of_Stack_Commit=%s,\n' % quote_python(self.Size_Of_Stack_Commit).encode(ExternalEncoding))
        if self.Size_Of_Heap_Reserve is not None:
            showIndent(outfile, level)
            outfile.write('Size_Of_Heap_Reserve=%s,\n' % quote_python(self.Size_Of_Heap_Reserve).encode(ExternalEncoding))
        if self.Size_Of_Heap_Commit is not None:
            showIndent(outfile, level)
            outfile.write('Size_Of_Heap_Commit=%s,\n' % quote_python(self.Size_Of_Heap_Commit).encode(ExternalEncoding))
        if self.Loader_Flags is not None:
            showIndent(outfile, level)
            outfile.write('Loader_Flags=%s,\n' % quote_python(self.Loader_Flags).encode(ExternalEncoding))
        if self.Number_Of_Rva_And_Sizes is not None:
            showIndent(outfile, level)
            outfile.write('Number_Of_Rva_And_Sizes=%s,\n' % quote_python(self.Number_Of_Rva_And_Sizes).encode(ExternalEncoding))
        if self.Data_Directory is not None:
            showIndent(outfile, level)
            outfile.write('Data_Directory=model_.DataDirectoryType(\n')
            self.Data_Directory.exportLiteral(outfile, level, name_='Data_Directory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Hashes is not None:
            showIndent(outfile, level)
            outfile.write('Hashes=%s,\n' % quote_python(self.Hashes).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Magic':
            Magic_ = child_.text
            Magic_ = self.gds_validate_string(Magic_, node, 'Magic')
            self.Magic = Magic_
        elif nodeName_ == 'Major_Linker_Version':
            Major_Linker_Version_ = child_.text
            Major_Linker_Version_ = self.gds_validate_string(Major_Linker_Version_, node, 'Major_Linker_Version')
            self.Major_Linker_Version = Major_Linker_Version_
        elif nodeName_ == 'Minor_Linker_Version':
            Minor_Linker_Version_ = child_.text
            Minor_Linker_Version_ = self.gds_validate_string(Minor_Linker_Version_, node, 'Minor_Linker_Version')
            self.Minor_Linker_Version = Minor_Linker_Version_
        elif nodeName_ == 'Size_Of_Code':
            Size_Of_Code_ = child_.text
            Size_Of_Code_ = self.gds_validate_string(Size_Of_Code_, node, 'Size_Of_Code')
            self.Size_Of_Code = Size_Of_Code_
        elif nodeName_ == 'Size_Of_Initialized_Data':
            Size_Of_Initialized_Data_ = child_.text
            Size_Of_Initialized_Data_ = self.gds_validate_string(Size_Of_Initialized_Data_, node, 'Size_Of_Initialized_Data')
            self.Size_Of_Initialized_Data = Size_Of_Initialized_Data_
        elif nodeName_ == 'Size_Of_Uninitialized_Data':
            Size_Of_Uninitialized_Data_ = child_.text
            Size_Of_Uninitialized_Data_ = self.gds_validate_string(Size_Of_Uninitialized_Data_, node, 'Size_Of_Uninitialized_Data')
            self.Size_Of_Uninitialized_Data = Size_Of_Uninitialized_Data_
        elif nodeName_ == 'Address_Of_Entry_Point':
            Address_Of_Entry_Point_ = child_.text
            Address_Of_Entry_Point_ = self.gds_validate_string(Address_Of_Entry_Point_, node, 'Address_Of_Entry_Point')
            self.Address_Of_Entry_Point = Address_Of_Entry_Point_
        elif nodeName_ == 'Base_Of_Code':
            Base_Of_Code_ = child_.text
            Base_Of_Code_ = self.gds_validate_string(Base_Of_Code_, node, 'Base_Of_Code')
            self.Base_Of_Code = Base_Of_Code_
        elif nodeName_ == 'Base_Of_Data':
            Base_Of_Data_ = child_.text
            Base_Of_Data_ = self.gds_validate_string(Base_Of_Data_, node, 'Base_Of_Data')
            self.Base_Of_Data = Base_Of_Data_
        elif nodeName_ == 'Image_Base':
            Image_Base_ = child_.text
            Image_Base_ = self.gds_validate_string(Image_Base_, node, 'Image_Base')
            self.Image_Base = Image_Base_
        elif nodeName_ == 'Section_Alignment':
            Section_Alignment_ = child_.text
            Section_Alignment_ = self.gds_validate_string(Section_Alignment_, node, 'Section_Alignment')
            self.Section_Alignment = Section_Alignment_
        elif nodeName_ == 'File_Alignment':
            File_Alignment_ = child_.text
            File_Alignment_ = self.gds_validate_string(File_Alignment_, node, 'File_Alignment')
            self.File_Alignment = File_Alignment_
        elif nodeName_ == 'Major_OS_Version':
            Major_OS_Version_ = child_.text
            Major_OS_Version_ = self.gds_validate_string(Major_OS_Version_, node, 'Major_OS_Version')
            self.Major_OS_Version = Major_OS_Version_
        elif nodeName_ == 'Minor_OS_Version':
            Minor_OS_Version_ = child_.text
            Minor_OS_Version_ = self.gds_validate_string(Minor_OS_Version_, node, 'Minor_OS_Version')
            self.Minor_OS_Version = Minor_OS_Version_
        elif nodeName_ == 'Major_Image_Version':
            Major_Image_Version_ = child_.text
            Major_Image_Version_ = self.gds_validate_string(Major_Image_Version_, node, 'Major_Image_Version')
            self.Major_Image_Version = Major_Image_Version_
        elif nodeName_ == 'Minor_Image_Version':
            Minor_Image_Version_ = child_.text
            Minor_Image_Version_ = self.gds_validate_string(Minor_Image_Version_, node, 'Minor_Image_Version')
            self.Minor_Image_Version = Minor_Image_Version_
        elif nodeName_ == 'Major_Subsystem_Version':
            Major_Subsystem_Version_ = child_.text
            Major_Subsystem_Version_ = self.gds_validate_string(Major_Subsystem_Version_, node, 'Major_Subsystem_Version')
            self.Major_Subsystem_Version = Major_Subsystem_Version_
        elif nodeName_ == 'Minor_Subsystem_Version':
            Minor_Subsystem_Version_ = child_.text
            Minor_Subsystem_Version_ = self.gds_validate_string(Minor_Subsystem_Version_, node, 'Minor_Subsystem_Version')
            self.Minor_Subsystem_Version = Minor_Subsystem_Version_
        elif nodeName_ == 'Win32_Version_Value':
            Win32_Version_Value_ = child_.text
            Win32_Version_Value_ = self.gds_validate_string(Win32_Version_Value_, node, 'Win32_Version_Value')
            self.Win32_Version_Value = Win32_Version_Value_
        elif nodeName_ == 'Size_Of_Image':
            Size_Of_Image_ = child_.text
            Size_Of_Image_ = self.gds_validate_string(Size_Of_Image_, node, 'Size_Of_Image')
            self.Size_Of_Image = Size_Of_Image_
        elif nodeName_ == 'Size_Of_Headers':
            Size_Of_Headers_ = child_.text
            Size_Of_Headers_ = self.gds_validate_string(Size_Of_Headers_, node, 'Size_Of_Headers')
            self.Size_Of_Headers = Size_Of_Headers_
        elif nodeName_ == 'Checksum':
            Checksum_ = child_.text
            Checksum_ = self.gds_validate_string(Checksum_, node, 'Checksum')
            self.Checksum = Checksum_
        elif nodeName_ == 'Subsystem':
            Subsystem_ = child_.text
            Subsystem_ = self.gds_validate_string(Subsystem_, node, 'Subsystem')
            self.Subsystem = Subsystem_
        elif nodeName_ == 'DLL_Characteristics':
            DLL_Characteristics_ = child_.text
            DLL_Characteristics_ = self.gds_validate_string(DLL_Characteristics_, node, 'DLL_Characteristics')
            self.DLL_Characteristics = DLL_Characteristics_
        elif nodeName_ == 'Size_Of_Stack_Reserve':
            Size_Of_Stack_Reserve_ = child_.text
            Size_Of_Stack_Reserve_ = self.gds_validate_string(Size_Of_Stack_Reserve_, node, 'Size_Of_Stack_Reserve')
            self.Size_Of_Stack_Reserve = Size_Of_Stack_Reserve_
        elif nodeName_ == 'Size_Of_Stack_Commit':
            Size_Of_Stack_Commit_ = child_.text
            Size_Of_Stack_Commit_ = self.gds_validate_string(Size_Of_Stack_Commit_, node, 'Size_Of_Stack_Commit')
            self.Size_Of_Stack_Commit = Size_Of_Stack_Commit_
        elif nodeName_ == 'Size_Of_Heap_Reserve':
            Size_Of_Heap_Reserve_ = child_.text
            Size_Of_Heap_Reserve_ = self.gds_validate_string(Size_Of_Heap_Reserve_, node, 'Size_Of_Heap_Reserve')
            self.Size_Of_Heap_Reserve = Size_Of_Heap_Reserve_
        elif nodeName_ == 'Size_Of_Heap_Commit':
            Size_Of_Heap_Commit_ = child_.text
            Size_Of_Heap_Commit_ = self.gds_validate_string(Size_Of_Heap_Commit_, node, 'Size_Of_Heap_Commit')
            self.Size_Of_Heap_Commit = Size_Of_Heap_Commit_
        elif nodeName_ == 'Loader_Flags':
            Loader_Flags_ = child_.text
            Loader_Flags_ = self.gds_validate_string(Loader_Flags_, node, 'Loader_Flags')
            self.Loader_Flags = Loader_Flags_
        elif nodeName_ == 'Number_Of_Rva_And_Sizes':
            Number_Of_Rva_And_Sizes_ = child_.text
            Number_Of_Rva_And_Sizes_ = self.gds_validate_string(Number_Of_Rva_And_Sizes_, node, 'Number_Of_Rva_And_Sizes')
            self.Number_Of_Rva_And_Sizes = Number_Of_Rva_And_Sizes_
        elif nodeName_ == 'Data_Directory':
            obj_ = DataDirectoryType.factory()
            obj_.build(child_)
            self.set_Data_Directory(obj_)
        elif nodeName_ == 'Hashes':
            Hashes_ = child_.text
            Hashes_ = self.gds_validate_string(Hashes_, node, 'Hashes')
            self.Hashes = Hashes_
# end class PEOptionalHeaderType


class DataDirectoryType(GeneratedsSuper):
    """The DataDirectoryType specifies the data directories that can appear
    in the PE file's optional header. The data directories, except
    the Certificate Table, are loaded into memory so they can be
    used at runtime."""
    subclass = None
    superclass = None
    def __init__(self, Export_Table=None, Import_Table=None, Resource_Table=None, Exception_Table=None, Certificate_Table=None, Base_Relocation_Table=None, Debug=None, Architecture=None, Global_Ptr=None, TLS_Table=None, Load_Config_Table=None, Bound_Import=None, Import_Address_Table=None, Delay_Import_Descriptor=None, CLR_Runtime_Header=None, Reserved=None):
        self.Export_Table = Export_Table
        self.Import_Table = Import_Table
        self.Resource_Table = Resource_Table
        self.Exception_Table = Exception_Table
        self.Certificate_Table = Certificate_Table
        self.Base_Relocation_Table = Base_Relocation_Table
        self.Debug = Debug
        self.Architecture = Architecture
        self.Global_Ptr = Global_Ptr
        self.TLS_Table = TLS_Table
        self.Load_Config_Table = Load_Config_Table
        self.Bound_Import = Bound_Import
        self.Import_Address_Table = Import_Address_Table
        self.Delay_Import_Descriptor = Delay_Import_Descriptor
        self.CLR_Runtime_Header = CLR_Runtime_Header
        self.Reserved = Reserved
    def factory(*args_, **kwargs_):
        if DataDirectoryType.subclass:
            return DataDirectoryType.subclass(*args_, **kwargs_)
        else:
            return DataDirectoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Export_Table(self): return self.Export_Table
    def set_Export_Table(self, Export_Table): self.Export_Table = Export_Table
    def get_Import_Table(self): return self.Import_Table
    def set_Import_Table(self, Import_Table): self.Import_Table = Import_Table
    def get_Resource_Table(self): return self.Resource_Table
    def set_Resource_Table(self, Resource_Table): self.Resource_Table = Resource_Table
    def get_Exception_Table(self): return self.Exception_Table
    def set_Exception_Table(self, Exception_Table): self.Exception_Table = Exception_Table
    def get_Certificate_Table(self): return self.Certificate_Table
    def set_Certificate_Table(self, Certificate_Table): self.Certificate_Table = Certificate_Table
    def get_Base_Relocation_Table(self): return self.Base_Relocation_Table
    def set_Base_Relocation_Table(self, Base_Relocation_Table): self.Base_Relocation_Table = Base_Relocation_Table
    def get_Debug(self): return self.Debug
    def set_Debug(self, Debug): self.Debug = Debug
    def get_Architecture(self): return self.Architecture
    def set_Architecture(self, Architecture): self.Architecture = Architecture
    def get_Global_Ptr(self): return self.Global_Ptr
    def set_Global_Ptr(self, Global_Ptr): self.Global_Ptr = Global_Ptr
    def get_TLS_Table(self): return self.TLS_Table
    def set_TLS_Table(self, TLS_Table): self.TLS_Table = TLS_Table
    def get_Load_Config_Table(self): return self.Load_Config_Table
    def set_Load_Config_Table(self, Load_Config_Table): self.Load_Config_Table = Load_Config_Table
    def get_Bound_Import(self): return self.Bound_Import
    def set_Bound_Import(self, Bound_Import): self.Bound_Import = Bound_Import
    def get_Import_Address_Table(self): return self.Import_Address_Table
    def set_Import_Address_Table(self, Import_Address_Table): self.Import_Address_Table = Import_Address_Table
    def get_Delay_Import_Descriptor(self): return self.Delay_Import_Descriptor
    def set_Delay_Import_Descriptor(self, Delay_Import_Descriptor): self.Delay_Import_Descriptor = Delay_Import_Descriptor
    def get_CLR_Runtime_Header(self): return self.CLR_Runtime_Header
    def set_CLR_Runtime_Header(self, CLR_Runtime_Header): self.CLR_Runtime_Header = CLR_Runtime_Header
    def get_Reserved(self): return self.Reserved
    def set_Reserved(self, Reserved): self.Reserved = Reserved
    def export(self, outfile, level, namespace_='WinExecutableFileObj:', name_='DataDirectoryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataDirectoryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='WinExecutableFileObj:', name_='DataDirectoryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='WinExecutableFileObj:', name_='DataDirectoryType', fromsubclass_=False):
        if self.Export_Table is not None:
            self.Export_Table.export(outfile, level, namespace_, name_='Export_Table')
        if self.Import_Table is not None:
            self.Import_Table.export(outfile, level, namespace_, name_='Import_Table')
        if self.Resource_Table is not None:
            self.Resource_Table.export(outfile, level, namespace_, name_='Resource_Table')
        if self.Exception_Table is not None:
            self.Exception_Table.export(outfile, level, namespace_, name_='Exception_Table')
        if self.Certificate_Table is not None:
            self.Certificate_Table.export(outfile, level, namespace_, name_='Certificate_Table')
        if self.Base_Relocation_Table is not None:
            self.Base_Relocation_Table.export(outfile, level, namespace_, name_='Base_Relocation_Table')
        if self.Debug is not None:
            self.Debug.export(outfile, level, namespace_, name_='Debug')
        if self.Architecture is not None:
            self.Architecture.export(outfile, level, namespace_, name_='Architecture')
        if self.Global_Ptr is not None:
            self.Global_Ptr.export(outfile, level, namespace_, name_='Global_Ptr')
        if self.TLS_Table is not None:
            self.TLS_Table.export(outfile, level, namespace_, name_='TLS_Table')
        if self.Load_Config_Table is not None:
            self.Load_Config_Table.export(outfile, level, namespace_, name_='Load_Config_Table')
        if self.Bound_Import is not None:
            self.Bound_Import.export(outfile, level, namespace_, name_='Bound_Import')
        if self.Import_Address_Table is not None:
            self.Import_Address_Table.export(outfile, level, namespace_, name_='Import_Address_Table')
        if self.Delay_Import_Descriptor is not None:
            self.Delay_Import_Descriptor.export(outfile, level, namespace_, name_='Delay_Import_Descriptor')
        if self.CLR_Runtime_Header is not None:
            self.CLR_Runtime_Header.export(outfile, level, namespace_, name_='CLR_Runtime_Header')
        if self.Reserved is not None:
            self.Reserved.export(outfile, level, namespace_, name_='Reserved')
    def hasContent_(self):
        if (
            self.Export_Table is not None or
            self.Import_Table is not None or
            self.Resource_Table is not None or
            self.Exception_Table is not None or
            self.Certificate_Table is not None or
            self.Base_Relocation_Table is not None or
            self.Debug is not None or
            self.Architecture is not None or
            self.Global_Ptr is not None or
            self.TLS_Table is not None or
            self.Load_Config_Table is not None or
            self.Bound_Import is not None or
            self.Import_Address_Table is not None or
            self.Delay_Import_Descriptor is not None or
            self.CLR_Runtime_Header is not None or
            self.Reserved is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataDirectoryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Export_Table is not None:
            showIndent(outfile, level)
            outfile.write('Export_Table=model_.PEDataDirectoryStructType(\n')
            self.Export_Table.exportLiteral(outfile, level, name_='Export_Table')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Import_Table is not None:
            showIndent(outfile, level)
            outfile.write('Import_Table=model_.PEDataDirectoryStructType(\n')
            self.Import_Table.exportLiteral(outfile, level, name_='Import_Table')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Resource_Table is not None:
            showIndent(outfile, level)
            outfile.write('Resource_Table=model_.PEDataDirectoryStructType(\n')
            self.Resource_Table.exportLiteral(outfile, level, name_='Resource_Table')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Exception_Table is not None:
            showIndent(outfile, level)
            outfile.write('Exception_Table=model_.PEDataDirectoryStructType(\n')
            self.Exception_Table.exportLiteral(outfile, level, name_='Exception_Table')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Certificate_Table is not None:
            showIndent(outfile, level)
            outfile.write('Certificate_Table=model_.PEDataDirectoryStructType(\n')
            self.Certificate_Table.exportLiteral(outfile, level, name_='Certificate_Table')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Base_Relocation_Table is not None:
            showIndent(outfile, level)
            outfile.write('Base_Relocation_Table=model_.PEDataDirectoryStructType(\n')
            self.Base_Relocation_Table.exportLiteral(outfile, level, name_='Base_Relocation_Table')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Debug is not None:
            showIndent(outfile, level)
            outfile.write('Debug=model_.PEDataDirectoryStructType(\n')
            self.Debug.exportLiteral(outfile, level, name_='Debug')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Architecture is not None:
            showIndent(outfile, level)
            outfile.write('Architecture=model_.PEDataDirectoryStructType(\n')
            self.Architecture.exportLiteral(outfile, level, name_='Architecture')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Global_Ptr is not None:
            showIndent(outfile, level)
            outfile.write('Global_Ptr=model_.PEDataDirectoryStructType(\n')
            self.Global_Ptr.exportLiteral(outfile, level, name_='Global_Ptr')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TLS_Table is not None:
            showIndent(outfile, level)
            outfile.write('TLS_Table=model_.PEDataDirectoryStructType(\n')
            self.TLS_Table.exportLiteral(outfile, level, name_='TLS_Table')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Load_Config_Table is not None:
            showIndent(outfile, level)
            outfile.write('Load_Config_Table=model_.PEDataDirectoryStructType(\n')
            self.Load_Config_Table.exportLiteral(outfile, level, name_='Load_Config_Table')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Bound_Import is not None:
            showIndent(outfile, level)
            outfile.write('Bound_Import=model_.PEDataDirectoryStructType(\n')
            self.Bound_Import.exportLiteral(outfile, level, name_='Bound_Import')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Import_Address_Table is not None:
            showIndent(outfile, level)
            outfile.write('Import_Address_Table=model_.PEDataDirectoryStructType(\n')
            self.Import_Address_Table.exportLiteral(outfile, level, name_='Import_Address_Table')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Delay_Import_Descriptor is not None:
            showIndent(outfile, level)
            outfile.write('Delay_Import_Descriptor=model_.PEDataDirectoryStructType(\n')
            self.Delay_Import_Descriptor.exportLiteral(outfile, level, name_='Delay_Import_Descriptor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CLR_Runtime_Header is not None:
            showIndent(outfile, level)
            outfile.write('CLR_Runtime_Header=model_.PEDataDirectoryStructType(\n')
            self.CLR_Runtime_Header.exportLiteral(outfile, level, name_='CLR_Runtime_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Reserved is not None:
            showIndent(outfile, level)
            outfile.write('Reserved=model_.PEDataDirectoryStructType(\n')
            self.Reserved.exportLiteral(outfile, level, name_='Reserved')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Export_Table':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Export_Table(obj_)
        elif nodeName_ == 'Import_Table':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Import_Table(obj_)
        elif nodeName_ == 'Resource_Table':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Resource_Table(obj_)
        elif nodeName_ == 'Exception_Table':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Exception_Table(obj_)
        elif nodeName_ == 'Certificate_Table':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Certificate_Table(obj_)
        elif nodeName_ == 'Base_Relocation_Table':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Base_Relocation_Table(obj_)
        elif nodeName_ == 'Debug':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Debug(obj_)
        elif nodeName_ == 'Architecture':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Architecture(obj_)
        elif nodeName_ == 'Global_Ptr':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Global_Ptr(obj_)
        elif nodeName_ == 'TLS_Table':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_TLS_Table(obj_)
        elif nodeName_ == 'Load_Config_Table':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Load_Config_Table(obj_)
        elif nodeName_ == 'Bound_Import':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Bound_Import(obj_)
        elif nodeName_ == 'Import_Address_Table':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Import_Address_Table(obj_)
        elif nodeName_ == 'Delay_Import_Descriptor':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Delay_Import_Descriptor(obj_)
        elif nodeName_ == 'CLR_Runtime_Header':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_CLR_Runtime_Header(obj_)
        elif nodeName_ == 'Reserved':
            obj_ = PEDataDirectoryStructType.factory()
            obj_.build(child_)
            self.set_Reserved(obj_)
# end class DataDirectoryType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Windows_Executable_File'
        rootClass = WindowsExecutableFileObjectType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Windows_Executable_File'
        rootClass = WindowsExecutableFileObjectType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="Windows_Executable_File",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Windows_Executable_File'
        rootClass = WindowsExecutableFileObjectType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from win_executable_file_object import *\n\n')
    sys.stdout.write('import win_executable_file_object as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "DOSHeaderType",
    "DataDirectoryType",
    "DetectedType",
    "EPJumpCodeType",
    "EntryPointSignatureListType",
    "EntryPointSignatureType",
    "FloatListType",
    "PEAttributesType",
    "PEChecksumType",
    "PEDataDirectoryStructType",
    "PEExportedFunctionType",
    "PEExportedFunctionsType",
    "PEExportsType",
    "PEFileHeaderType",
    "PEHeadersType",
    "PEImportListType",
    "PEImportType",
    "PEImportedFunctionType",
    "PEImportedFunctionsType",
    "PEOptionalHeaderType",
    "PEResourceListType",
    "PEResourceType",
    "PESectionHeaderStructType",
    "PESectionListType",
    "PESectionType",
    "PEStringType",
    "PEType",
    "SectionType",
    "StringListType",
    "SubsystemType",
    "WindowsExecutableFileObjectType"
    ]
